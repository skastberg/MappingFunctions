////////////////////////////////////////////////////////////////////////
//
// DecimalFormatParser.cs
//
// This file was generated by MapForce 2011.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the MapForce Documentation for further details.
// http://www.altova.com/mapforce
//
////////////////////////////////////////////////////////////////////////
using System.Text;
using System.Globalization;

namespace Altova.Functions
{

public class DecimalFormatParser 
{
	public class DecimalFormat
	{
		public DecimalFormat() {
			msName = "";

			// decimal-separator specifies the character used for the decimal sign; the default value is the period character (.)
			mcDecimalSeparator = '.';

			// grouping-separator specifies the character used as a grouping (e.g. thousands) separator; the default value is the comma character (,)
			mcGroupingSeparator = ',';

			// percent specifies the character used as a percent sign; the default value is the percent character (%)
			mcPercent = '%';

			// per-mille specifies the character used as a per mille sign; the default value is the Unicode per-mille character (#x2030)
			mcPerMille = (char)0x2030;

			// zero-digit specifies the character used as the digit zero; the default value is the digit zero (0)
			mcZeroDigit = '0';

			// The following attributes control the interpretation of characters in the format pattern:

			// digit specifies the character used for a digit in the format pattern; the default value is the number sign character (#)
			mcDigit = '#';

			// pattern-separator specifies the character used to separate positive and negative sub patterns in a pattern; the default value is the semi-colon character (;)
			mcPatternSeparator = ';';

			// The following attributes specify characters or strings that may appear in the result of formatting the number:

			// infinity specifies the string used to represent infinity; the default value is the string Infinity 
			msInfinity = "Infinity";

			// NaN specifies the string used to represent the NaN value; the default value is the string NaN 
			msNaN = "NaN";

			// minus-sign specifies the character used as the default minus sign; the default value is the hyphen-minus character (-, #x2D)
			mcMinusSign = '-';
		}

		public string Name {
			get { return msName; }
			set { msName = value; }
		}

		public char DecimalSeparator {
			get { return mcDecimalSeparator; }
			set { mcDecimalSeparator = value; }
		}

		public char GroupingSeparator {
			get { return mcGroupingSeparator; }
			set { mcGroupingSeparator = value; }
		}

		public string Infinity {
			get { return msInfinity; }
			set { msInfinity = value; }
		}

		public char MinusSign {
			get { return mcMinusSign; }
			set { mcMinusSign = value; }
		}

		public string NaN {
			get { return msNaN; }
			set { msNaN = value; }
		}

		public char Percent {
			get { return mcPercent; }
			set { mcPercent = value; }
		}

		public char PerMille {
			get { return mcPerMille; }
			set { mcPerMille = value; }
		}

		public char ZeroDigit {
			get { return mcZeroDigit; }
			set { mcZeroDigit = value; }
		}

		public char Digit {
			get { return mcDigit; }
			set { mcDigit = value; }
		}

		public char PatternSeparator {
			get { return mcPatternSeparator; }
			set { mcPatternSeparator = value; }
		}

		public bool HasDistinctValues()
		{
			if ( mcDecimalSeparator == mcGroupingSeparator || mcDecimalSeparator == mcPercent ||
				mcDecimalSeparator == mcPerMille || mcDecimalSeparator == mcZeroDigit ||
				mcDecimalSeparator == mcDigit || mcDecimalSeparator == mcPatternSeparator )
			{
				return false;
			}
			else if ( mcGroupingSeparator == mcPercent || mcGroupingSeparator == mcPerMille ||
				mcGroupingSeparator == mcZeroDigit || mcGroupingSeparator == mcDigit ||
				mcGroupingSeparator == mcPatternSeparator )
			{
				return false;
			} 
			else if ( mcPercent == mcPerMille || mcPercent == mcZeroDigit || mcPercent == mcDigit ||
				mcPercent == mcPatternSeparator )
			{
				return false;
			}
			else if ( mcPerMille == mcZeroDigit || mcPerMille == mcDigit || mcPerMille == mcPatternSeparator )
			{
				return false;
			}
			else if ( mcZeroDigit == mcDigit || mcZeroDigit == mcPatternSeparator )
			{
				return false;	
			}
			else if ( mcDigit == mcPatternSeparator )
			{
				return false;
			}
			return true;
		}

		//MapForceDecimalFormat& operator=( const MapForceDecimalFormat& rRight );
		//bool operator==( const MapForceDecimalFormat& rRight ) const;

		protected string			msName;					// = qname 
		protected char				mcDecimalSeparator;		// = char 
		protected char				mcGroupingSeparator;	// = char 
		protected string			msInfinity;				// = string 
		protected char				mcMinusSign;			// = char 
		protected string			msNaN;					// = string 
		protected char				mcPercent;				// = char 
		protected char				mcPerMille;				// = char 
		protected char				mcZeroDigit;			// = char 
		protected char				mcDigit;				// = char 
		protected char				mcPatternSeparator;		// = char
	};
	
	protected class Format
	{
		public Format()
		{
			Reset();
		}

		void Reset()
		{
			mbPrefix = false;
			mbSuffix = false;
			mbDecimalSeperator = false;
			mnNonZeroDigits = 0;			// #
			mnZeroDigits = 0;				// 0
			mnNonZeroDigitsFraction = 0;	// #
			mnZeroDigitsFraction = 0;		// 0
			mnGroupSpace = 0;				// ,
			mbGroup = false;
			mcDecimal = '.';
			mcSign = '-';
			mbPercent = false;
			mbPerMille = false;
		}

		public bool mbPrefix;
		public bool mbSuffix;
		public bool mbDecimalSeperator;
		public int mnNonZeroDigits;			// #
		public int mnZeroDigits;				// 0
		public int mnNonZeroDigitsFraction;	// #
		public int mnZeroDigitsFraction;		// 0
		public int mnGroupSpace;				// ,
		public bool mbGroup;
		public char mcSuffix;
		public char mcDecimal;
		public char mcSign;
		public bool mbPercent;
		public bool mbPerMille;
	}
	
	public DecimalFormatParser()
	{ 
		mDecimalFormat = null;
		mbNegativePattern = false;
		mbHasMinusSign = false;
	}

	public bool setPattern (string sExpr, DecimalFormat format)
	{
		return setPattern(sExpr, format, false);
	}

	public bool setPattern ( string sExpr, DecimalFormat format, bool bTrim )
	{
		StringBuilder sPattern = new StringBuilder(sExpr);
		if (format == null)
			return false;

		msPrefixText = "";
		msSuffixText = "";
		msNegPrefixText = "";
		msNegSuffixText = "";

		mNegativeFormat = new Format();
		mPositiveFormat = new Format();
		mbNegativePattern = false;

		mFormat = mPositiveFormat;

		mDecimalFormat = format;

		bool bRet = pattern( sPattern, bTrim );

		if ( sPattern.Length > 0 )
			bRet = false;

		return bRet;
	}

	string GetPrefixText() { return msPrefixText; }
	string GetSuffixText() { return msSuffixText; }

	protected bool addMinusSignIfAllowed(char cCurrent)
	{
		if ( ( mbHasMinusSign == false )
			&& ( cCurrent == mDecimalFormat.MinusSign ) )
		{
			mbHasMinusSign = mbNegativePattern;
			return true;
		}
		return false;
	}
	
	protected bool pattern (StringBuilder sExpr, bool bTrim)
	{
		if (bTrim)
		{
			Lang.LeftTrim(sExpr, "\t ");
		}
		if ( sExpr.Length == 0 )
			return false;

		msPrefixText = "";
		msSuffixText = "";

		if( !subPattern( sExpr ) )
			return false;

		if(bTrim)
		{
			msSuffixText = Lang.RightTrim(msSuffixText);
		}
		
		if ( sExpr.Length > 0 )
		{
			if( sExpr[0] == mDecimalFormat.PatternSeparator )
				sExpr.Remove(0, 1);
			else
				return true;
	
			mbNegativePattern = true;
			mFormat = mNegativeFormat;
			if (bTrim)
			{
				Lang.LeftTrim(sExpr, "\t ");
				Lang.RightTrim(sExpr, "\t ");
			}
			return subPattern( sExpr );
		}

		return true;
	}
	
	protected bool subPattern ( StringBuilder sExpr )
	{
		if ( sExpr.Length == 0 )
			return false;


		prefixText( sExpr );

		prefix( sExpr );
		
		if( !integer( sExpr ) )
			return false;

		if( sExpr.Length > 0 && sExpr[0] == mDecimalFormat.DecimalSeparator )
		{
			mFormat.mbDecimalSeperator = true;

			sExpr.Remove(0,1);

			if( !fraction( sExpr ) )
				return false;
		}
		
		suffix( sExpr );
		suffixText( sExpr );

		return true;
	}
	
	protected bool prefix ( StringBuilder sExpr )
	{
		if ( sExpr.Length == 0 )
			return false;

		if ( sExpr[0] == mDecimalFormat.Percent ) 
		{
			sExpr.Remove(0, 1);
			mFormat.mbPrefix = true;
			mFormat.mbPercent = true;
			mFormat.mbPerMille = false;
			return true;
		}
		else if ( sExpr[0] == mDecimalFormat.PerMille ) 
		{
			sExpr.Remove(0, 1);
			mFormat.mbPrefix = true;
			mFormat.mbPercent = false;
			mFormat.mbPerMille = true;
			return true;
		}

		return false;
	}
	
	protected bool prefixText ( StringBuilder sExpr )
	{
		if ( sExpr.Length == 0 )
			return false;

		bool bInQuotes = false;
		int i = 0;
		int nLength = sExpr.Length;
		while ( ( i < nLength ) && ( bInQuotes || notSpecialChar(sExpr[i]) || addMinusSignIfAllowed(sExpr[i]) ) )
		{
			if ( sExpr[i] == '\'' )
			{
				i++;
				
				if ( i < nLength )
				{
					bInQuotes = !bInQuotes;
					break;
				}
				else if ( sExpr[i] != '\'' )
					bInQuotes = !bInQuotes;
			}
			
			if( mbNegativePattern )
				msNegPrefixText += sExpr[i];
			else
				msPrefixText += sExpr[i];

			i++;
		}
		
		sExpr.Remove(0, i);
		return !bInQuotes;
	}
	
	protected bool integer ( StringBuilder sExpr )
	{
		if ( sExpr.Length == 0 )
			return false;

		char cLast = mDecimalFormat.ZeroDigit;

		// how many Non Zero Digits
		int i = 0;
		int nLength = sExpr.Length;
		while ( ( i < nLength ) && ( ( sExpr[i] == mDecimalFormat.Digit ) || ( sExpr[i] == mDecimalFormat.GroupingSeparator ) ) )
		{
			if ( sExpr[i] == mDecimalFormat.GroupingSeparator )
			{
				mFormat.mnGroupSpace = 0;
				mFormat.mbGroup = true;
			}
			else
			{
				mFormat.mnGroupSpace++;
				mFormat.mnNonZeroDigits++;
			}

			cLast = sExpr[i];
			i++;
		}

		/* java 1.1.8 needs this but every implementation allows formating without specifying the minlength 
		if ( ( **pszExpr != 0 ) && ( **pszExpr != m_pDecimalFormat->GetZeroDigit() ) )
		{
			return false;
		}*/

		// how many Zero Digits
		while ( ( i < nLength ) && ( ( sExpr[i] == mDecimalFormat.ZeroDigit ) || ( sExpr[i] == mDecimalFormat.GroupingSeparator ) ))
		{
			if ( sExpr[i] == mDecimalFormat.GroupingSeparator )
			{
				mFormat.mnGroupSpace = 0;
				mFormat.mbGroup = true;
			}
			else
			{
				mFormat.mnGroupSpace++;
				mFormat.mnZeroDigits++;
			}

			cLast = sExpr[i];

			i++;
		}
		sExpr.Remove(0, i);

		if ( cLast == mDecimalFormat.GroupingSeparator ) 
			return false;
		else
			return true;
	}
	
	protected bool fraction ( StringBuilder sExpr )
	{
		if ( sExpr.Length == 0 )
			return false;

		// how many Zero Digits in the fraction
		int i = 0;
		int nLength = sExpr.Length;
		while ( ( i < nLength ) && ( sExpr[i] == mDecimalFormat.ZeroDigit ) )
		{
			mFormat.mnZeroDigitsFraction++;
			i++;
		}

		// how many Non Zero Digits
		while ( ( i < nLength ) && ( sExpr[i] == mDecimalFormat.Digit ) )
		{
			mFormat.mnNonZeroDigitsFraction++;
			i++;
		}
		sExpr.Remove(0, i);

		return true;
	}
	
	protected bool suffix ( StringBuilder sExpr )
	{
		if ( sExpr.Length == 0 )
			return false;

		if( sExpr[0] > 0xFFFD )
			return false;

		if ( sExpr[0] == mDecimalFormat.Percent ) 
		{
			sExpr.Remove(0, 1);
			mFormat.mbSuffix = true;
			mFormat.mbPercent = true;
			mFormat.mbPerMille = false;
			return true;
		}
		else if ( sExpr[0] == mDecimalFormat.PerMille ) 
		{
			sExpr.Remove(0, 1);
			mFormat.mbSuffix = true;
			mFormat.mbPercent = false;
			mFormat.mbPerMille = true;
			return true;
		}

		return false;
	}
	
	protected bool suffixText ( StringBuilder sExpr )
	{
		if ( sExpr.Length == 0 )
			return false;

		bool bInQuotes = false;
		int i = 0;
		int nLength = sExpr.Length;
		while ( ( i < nLength ) && ( bInQuotes || notSpecialChar( sExpr[i] ) || addMinusSignIfAllowed( sExpr[i] ) ) )
		{
			if ( sExpr[i] == '\'' )
			{
				i++;
				
				if ( i < nLength )
				{
					bInQuotes = !bInQuotes;
					break;
				}
				else if ( sExpr[i] != '\'' )
				{
					bInQuotes = !bInQuotes;
				}
			}
			if( mbNegativePattern )
				msNegSuffixText += sExpr[i];
			else
				msSuffixText += sExpr[i];
			i++;
		}
		sExpr.Remove(0, i);
		return !bInQuotes;
	}
	
	protected bool notSpecialChar ( char cChar )
	{
		if ( cChar == mDecimalFormat.DecimalSeparator )	return false;
		else if ( cChar == mDecimalFormat.Digit )			return false;
		else if ( cChar == mDecimalFormat.GroupingSeparator)return false;
		else if ( cChar == mDecimalFormat.MinusSign )		return false;
		else if ( cChar == mDecimalFormat.PatternSeparator )return false;
		else if ( cChar == mDecimalFormat.ZeroDigit )		return false;
		else if ( cChar == mDecimalFormat.Percent )		return false;
		else if ( cChar == mDecimalFormat.PerMille )		return false;

		return true;
	}
	
	protected static string roundHalfUp( decimal fvalue, int precision )
	{
		StringBuilder result = new StringBuilder(
				fvalue.ToString(System.Globalization.CultureInfo.InvariantCulture) //ensure we get dots and no comma
			);

		bool bNegativ = result[0] == '-';
		if( bNegativ )
			result.Remove(0, 1);
		int nDecPos = result.ToString().IndexOf( "." );

		if( nDecPos >= 0 )
		{
			int nLength = result.Length;
			if( nDecPos + precision + 1< nLength)
			{
				int i = nDecPos + precision + 1;
				bool bCarry = false;
				result.Remove(i + 1, nLength - (i+1)); //remove everything after precision + 1
				
				bCarry = result[i] >= '5';
				result[i] = '0';
				i--;

				while( bCarry && i >= 0 )
				{
					if( result[i] != '.' )
					{
						if( bCarry = ( result[i] == '9' ) )
							result[i] = '0';
						else
							result[i] = (char)(result[i] + 1);
					}
					i--;
				}
				Lang.RightTrim(result, "0");
				if( i < 0 && bCarry)
					result.Insert(0, '1');
			}
			Lang.RightTrim(result, ".");
		}
		if( bNegativ )
			result.Insert(0, '-');
		return result.ToString();
	}
	
	public string formatNumber ( decimal nNumber )
	{
		StringBuilder sbFormat = new StringBuilder("");

		if ( mDecimalFormat == null )
			return sbFormat.ToString();
/*
		Double nCheck = new Double(nNumber.doubleValue() );
		if( nCheck.isInfinite() )
		{
			if( Double.POSITIVE_INFINITY == nCheck)
				return mDecimalFormat.Infinity;
			else
			{
				sbFormat.Append( mDecimalFormat.MinusSign );
				sbFormat.Append( mDecimalFormat.Infinity );
				return sbFormat.ToString();
			}
		}
		if( nCheck.isNaN() )
			return mDecimalFormat.NaN;
*/
		//TODO
		//if ( ICUnicode::IsLetter( m_pDecimalFormat->GetZeroDigit() ) )
		//{
		//	m_nDigitTranslation = m_pDecimalFormat->GetZeroDigit() - _T('0');
		//}
		//else
		{
			mnDigitTranslation = 0;
		}
		
		if ( mFormat.mbPercent )
			nNumber *= 100 ;
		else if ( mFormat.mbPerMille )
			nNumber *= 1000;

		if ( ( nNumber < 0 ) && mbNegativePattern )
			mFormat = mNegativeFormat;
		else
			mFormat = mPositiveFormat;

		mFormat.mcDecimal = (char)0;
		mFormat.mcSign = (char)0;

		int iSign = 0;
		int iDecimalPos = -1;

		StringBuilder sbRight = new StringBuilder();
		StringBuilder sbLeft = new StringBuilder();

		StringBuilder sNumber = new StringBuilder(
				roundHalfUp( nNumber, 
					mFormat.mnZeroDigitsFraction + mFormat.mnNonZeroDigitsFraction
				)
			);

		iDecimalPos = sNumber.ToString().IndexOf( "." );
		if( iDecimalPos >= 0 )
			sNumber.Remove( iDecimalPos, 1);
		else
		{
			if( sNumber.ToString() == "0" || sNumber.ToString() == "-0" ) //special case for 0
				iDecimalPos = 0;
			else
				iDecimalPos = sNumber.Length;
		}

		if( nNumber < 0)
		{
			iSign = sNumber.ToString().IndexOf( "-" );
			if ( iSign >= 0 )
			{
				sNumber.Remove(iSign, 1);
				iSign = 1;
				iDecimalPos--;
			}
		}
		else
			iSign = 0;

		if ( iDecimalPos <= 0 )
		{
			// add preceding number of 0s
			int iAbsDecimalPos = System.Math.Abs( iDecimalPos );
			for( int i = 0; i < iAbsDecimalPos; i++) sbRight.Append('0');

			sbRight.Append( sNumber );
		}
		else
		{
			sbLeft.Append( sNumber.ToString().Substring( 0, iDecimalPos ) );
			sbRight.Append(sNumber.ToString().Substring(iDecimalPos));
		}

		// remove extra zero padding off the end
		int nLastZero = sbRight.Length;
		while( nLastZero > 0 && sbRight[nLastZero - 1] == '0') 
			nLastZero--;
		//int nLastZero = sbRight.ReverseFindOneNotOf( _T("0") ) + 1;
		if( nLastZero >= 0 && nLastZero < sbRight.Length)
			sbRight.Remove( nLastZero, sbRight.Length - nLastZero );

		// now add correct amount
		int iRightLen = sbRight.Length;
		if ( iRightLen < mFormat.mnZeroDigitsFraction )
			for( int i = 0; i < mFormat.mnZeroDigitsFraction - iRightLen; i++) sbRight.Append('0');

		// prefix zero padding if needed
		Lang.LeftTrim( sbLeft, "0");
		int iLeftLen = sbLeft.Length;
		if ( iLeftLen < mFormat.mnZeroDigits )
		{
			int iPadSize = mFormat.mnZeroDigits - iLeftLen;
			for( int i = 0; i < iPadSize; i++) sbLeft.Insert(0, '0');
		}

		if ( sbLeft.Length == 0 && sbRight.Length == 0 )
			sbLeft.Append( "0" );

		// translate left and right sides
		for( int i = 0; i < sbLeft.Length; ++i)
			sbLeft[i] = (char)(sbLeft[i] + mnDigitTranslation);

		for( int i = 0; i < sbRight.Length; ++i)
			sbRight[i] = (char)(sbRight[i] + mnDigitTranslation);
		
		// do the grouping, ','
		if ( ( mFormat.mbGroup ) && ( mFormat.mnGroupSpace > 0 ) && ( sbLeft.Length > mFormat.mnGroupSpace ) )
		{
			string sTemp = "";
			char cFormat = mDecimalFormat.GroupingSeparator;

			int niLeftPos = 0;
			int nFirstGroupPos = sbLeft.Length % mFormat.mnGroupSpace;
			
			if ( nFirstGroupPos > 0 )
			{
				sTemp = sbLeft.ToString().Substring( 0, nFirstGroupPos );
				niLeftPos = nFirstGroupPos;
				sTemp += cFormat;
			}

			while( niLeftPos < sbLeft.Length )
			{
				sTemp += sbLeft.ToString().Substring( niLeftPos, mFormat.mnGroupSpace );
				niLeftPos += mFormat.mnGroupSpace;

				if ( niLeftPos < sbLeft.Length )
					sTemp += cFormat;
			}
			sbLeft = new StringBuilder(sTemp);
		}

		// start to assemble the string in sFormat
		sbFormat = new StringBuilder();

		// add the sign
		if ( !mbNegativePattern && ( iSign != 0 ) )
			sbFormat.Append( mDecimalFormat.MinusSign );

		// add the prefix
		if ( mFormat.mbPrefix )
		{
			if ( mFormat.mbPercent )
				sbFormat.Append( mDecimalFormat.Percent );
			else if ( mFormat.mbPerMille )
				sbFormat.Append( mDecimalFormat.PerMille );
		}

		// prefix text
		if ( ( nNumber >= 0 ) || !mbNegativePattern )
			sbFormat.Append( msPrefixText );
		else
			sbFormat.Append( msNegPrefixText );

		// add the left side
		sbFormat.Append( sbLeft );
		
		if ( mFormat.mbDecimalSeperator && sbRight.Length > 0 )
		{
			sbFormat.Append( mDecimalFormat.DecimalSeparator );
			sbFormat.Append( sbRight );
		}

		// add the suffix
		if ( mFormat.mbSuffix )
		{
			if ( mFormat.mbPercent )
				sbFormat.Append( mDecimalFormat.Percent );
			else if ( mFormat.mbPerMille )
				sbFormat.Append( mDecimalFormat.PerMille );
		}

		// suffix text
		if ( ( nNumber >= 0 ) || !mbNegativePattern )
			sbFormat.Append( msSuffixText );
		else
			sbFormat.Append( msNegSuffixText );

		// if the zero digit or digit symbol is alpha translate the string

		return sbFormat.ToString();
	}

	public decimal parseNumber( string sNumber) {
		decimal dec;
		StringBuilder sReadInput = new StringBuilder(sNumber.Trim());
		string sUsedPrefixText = msPrefixText;
		string sUsedSuffixText = msSuffixText;
		bool bIsNegative;

		mFormat = mPositiveFormat;
		if( bIsNegative = isNegativeNumber(sReadInput.ToString()) )
		{
			if( mbNegativePattern )
			{
				sUsedPrefixText = msNegPrefixText;
				sUsedSuffixText = msNegSuffixText;
				mFormat = mNegativeFormat;
			}
		}

		if( sUsedPrefixText.Length > 0 )
		{
			if( sReadInput.ToString().StartsWith( sUsedPrefixText ) )
				sReadInput.Remove(0, sUsedPrefixText.Length );
			else
				throw new System.ArgumentException(
					"Prefix doesn't match: '" + sUsedPrefixText + "'"
				);
		}

		if( sUsedSuffixText.Length > 0 )
		{
			if( sReadInput.ToString().EndsWith( sUsedSuffixText ) )
				sReadInput.Remove( sReadInput.Length - sUsedSuffixText.Length, sUsedSuffixText.Length );
			else
				throw new System.ArgumentException(
					"Suffix doesn't match: '" + sUsedSuffixText + "'"
				);
		}

		if( mFormat.mbGroup )
			sReadInput.Replace(mDecimalFormat.GroupingSeparator + "", "");


		//check if rest of string a valid number
		try {
			CultureInfo culture = new CultureInfo(CultureInfo.CurrentCulture.Name);
			NumberFormatInfo numInfo = culture.NumberFormat;
			numInfo.NumberDecimalSeparator = "" + mDecimalFormat.DecimalSeparator;
			dec = decimal.Parse(sReadInput.ToString(), NumberStyles.Float, numInfo );
		}
		catch (System.Exception)
		{
			throw new System.ArgumentException(
				"Value is not a number: '" + sReadInput + "'"
			);
		}

		if( bIsNegative && dec >= 0 )
			dec *= -1;
		return dec;
	}
	
	private bool isNegativeNumber(string sNumber) {
		if( msNegPrefixText.Length > 0 && sNumber.StartsWith( msNegPrefixText) )
		{
			if( msNegSuffixText.Length > 0 && sNumber.EndsWith( msNegSuffixText) )
				return true;
		}
		else if( msPrefixText.Length > 0 && sNumber.StartsWith(msPrefixText) )
		{
			if( sNumber.IndexOf( mDecimalFormat.MinusSign, msPrefixText.Length ) != -1 )
				return true;
			else
				return false;
		}
		else
		{
			int nMinusPos = sNumber.IndexOf(mDecimalFormat.MinusSign);
			if (nMinusPos != -1)
			{
				if (nMinusPos == 0)
					return true;
				char maybeE = sNumber[nMinusPos - 1];
				if (maybeE == 'E' || maybeE == 'e')
					return false;

				return true;
			}
		}

		return false;
	}

	protected Format			mPositiveFormat;
	protected Format			mNegativeFormat;
	protected Format			mFormat;

	protected bool				mbNegativePattern;
	protected bool				mbHasMinusSign;
	protected DecimalFormat		mDecimalFormat;

	protected string			msPrefixText;
	protected string			msSuffixText;
	protected string			msNegPrefixText;
	protected string			msNegSuffixText;
	protected int				mnDigitTranslation;
}

}

