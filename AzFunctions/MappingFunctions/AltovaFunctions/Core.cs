//
// Core.cs
//
// This file was generated by MapForce 2021r3.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the MapForce Documentation for further details.
// http://www.altova.com/mapforce
//

using System;
using System.Xml;
using System.Collections;
using System.Collections.Generic;
using Altova.Types;
using Altova.Mapforce;
using System.Text.RegularExpressions;

namespace Altova.Functions
{
	public interface ISequenceTarget
	{
		void Add(string o);
		void Add(int o);
		void Add(uint o);
		void Add(long o);
		void Add(ulong o);
		void Add(byte[] o);
		void Add(decimal o);
		void Add(double o);
		void Add(object o);
	}

	public class RuntimeContext
	{
		private Hashtable autoNumberStateMap;

		public struct AutoNumberStateEntry
		{
			public long current;
			public string restartOnChange;
			public AutoNumberStateEntry(long current, string restartOnChange) 
			{
				this.current=current; 
				this.restartOnChange = restartOnChange;
			}
		}
		
		public Hashtable AutoNumberStateMap 
		{ 
			get 
			{ 
				if (autoNumberStateMap == null) 
					autoNumberStateMap = new Hashtable(); 
				return autoNumberStateMap; 
			} 
		}
				
		public static void Dispose(Altova.Functions.RuntimeContext context) 
		{ 
			if (context.autoNumberStateMap != null) 
				context.autoNumberStateMap.Clear(); 
		}
		public static Altova.Functions.RuntimeContext Construct() 
		{ 
			return new Altova.Functions.RuntimeContext(); 
		}
		
		private RuntimeContext() {}
	}

	public class Core
	{
		public abstract class NumericalSequenceTarget : ISequenceTarget
		{
			public void Add(string o) { Add(Altova.CoreTypes.CastToDecimal(o)); }
			public void Add(int o) { Add(Altova.CoreTypes.CastToDecimal(o)); }
			public void Add(uint o) { Add(Altova.CoreTypes.CastToDecimal(o)); }
			public void Add(long o) { Add(Altova.CoreTypes.CastToDecimal(o)); }
			public void Add(ulong o) { Add(Altova.CoreTypes.CastToDecimal(o)); }
			public void Add(byte[] o) { throw new Altova.Types.ConversionException("Cannot convert binary to decimal."); }
			public abstract void Add(decimal o);
			public void Add(double o) { Add(Altova.CoreTypes.CastToDecimal(o)); }
			public void Add(object o) { if (o != null) Add(Altova.CoreTypes.CastToDecimal(o)); }
		};

		public static IMFNode ShallowCopy(IMFNode source, IEnumerable content)
		{
			if (source.NodeKind == MFNodeKind.Attribute || source.NodeKind == MFNodeKind.Field)
				return new MFAttribute(source.LocalName, source.NamespaceURI, source.Prefix, content);
			return new MFElement(source.LocalName, source.NamespaceURI, source.Prefix, content);
		}
	
		public class SequenceCache : IEnumerable
		{
			private readonly ArrayList elements;
			private IEnumerable sourceSequence;

			public SequenceCache (IEnumerable source)
			{
				sourceSequence = source;
				elements = new ArrayList();
			}

			public IEnumerator GetEnumerator() {return new Enumerator (this);}
			public void Append(object o) {elements.Add(o);}
			public static void fillCache(SequenceCache sc)
			{
				IEnumerator en = sc.sourceSequence.GetEnumerator();
				while (en.MoveNext())
					sc.Append(en.Current);
				
				sc.sourceSequence = null;
			}

			public class Enumerator : IMFEnumerator
			{
				private readonly SequenceCache cache;
				private int pos = 0;

				public Enumerator(SequenceCache sc)
				{
					cache = sc;
				}

				public object Current {get{return cache.elements[pos-1];}}

				public void Reset() {}

				public bool MoveNext()
				{
					if (cache.sourceSequence != null)
						SequenceCache.fillCache(cache);

					return ++pos <= cache.elements.Count;
				}

				public int Position { get {return pos;} }
				public void Dispose() {}				
			}
		}

		public static IEnumerable DistinctValues(IEnumerable x)
		{
			return new DistinctEnumerable(x);
		}

		class DistinctEnumerable : IEnumerable
		{
			private readonly IEnumerable x;

			public DistinctEnumerable(IEnumerable x)
			{
				this.x = x;
			}

			public IEnumerator GetEnumerator() { return new Enumerator(x.GetEnumerator()); }

			public class Enumerator : IMFEnumerator
			{
				private readonly IEnumerator x;
				private readonly Hashtable v;
				private int pos = 0;

				public Enumerator(IEnumerator x)
				{

					this.x = x;
					v = new Hashtable();
				}

				public bool MoveNext()
				{
					while (x.MoveNext())
					{
						if (!v.ContainsKey(x.Current))
						{
							v.Add(x.Current, null);
							pos++;
							return true;
						}
					}
					return false;
				}

				public void Reset() {}

				public object Current { get { return x.Current; } }

				public int Position { get { return pos; } }
				public void Dispose() { MFEnumerator.Dispose(x); }
			}
		}

		public static string GroupingKey(Altova.Mapforce.Group g) { return (string) g.Key; }

		static IEnumerable ConcatMaps(IEnumerable x, MFInvoke y)
		{
			return new ConcatMapsEnumerable(x, y);
		}

		class ConcatMapsEnumerable : IEnumerable
		{
			private readonly IEnumerable x;
			private readonly MFInvoke y;

			public ConcatMapsEnumerable(IEnumerable source, MFInvoke lambda)
			{
				x = source;
				y = lambda;
			}

			public IEnumerator GetEnumerator()
			{
				return new Enumerator(x.GetEnumerator(), y);
			}

			class Enumerator : IMFEnumerator
			{
				private readonly IEnumerator x;
				private readonly MFInvoke y;
				private IEnumerator results = null;
				private int pos = 0;

				public Enumerator(IEnumerator source, MFInvoke lambda)
				{
					x = source;
					y = lambda;
				}

				public object Current { get { return results.Current; } }

				public bool MoveNext()
				{
					while (true)
					{
						if (results == null)
						{
							if (!x.MoveNext())
								return false;

							IEnumerable res = (IEnumerable)y(x.Current);

							results = res.GetEnumerator();
						}

						if (results.MoveNext())
						{
							pos++;
							return true;
						}

						MFEnumerator.Dispose(results);
						results = null;
					}
				}

				public int Position { get { return pos; } }

				public void Reset() {}
				public void Dispose() { MFEnumerator.Dispose(x); }
			}
		}

		delegate object MapFunction(object o);
		static IEnumerable Map(IEnumerable x, MapFunction y)
		{
			return new MapEnumerable(x, y);
		}

 
		class MapEnumerable : IEnumerable
		{
			private readonly IEnumerable x;
			private readonly MapFunction y;

			public MapEnumerable(IEnumerable source, MapFunction lambda)
			{
				x = source;
				y = lambda;
			}
			public IEnumerator GetEnumerator() {return new Enumerator(x.GetEnumerator(), y);}

			class Enumerator : IMFEnumerator
			{
				private readonly IEnumerator x;
				private readonly MapFunction y;
				private int pos = 0;

				public Enumerator(IEnumerator source, MapFunction lambda)
				{
					x = source;
					y = lambda;
				}
				
				public object Current { get { return y(x.Current);} }

				public bool MoveNext() 
				{
					if(!x.MoveNext())
						return false;
					pos++;
					return true;
				}

				public int Position { get { return pos; } }

				public void Reset() {}
				public void Dispose() { MFEnumerator.Dispose(x); }
			}
		}

		delegate bool FilterFunction(object o);

		static IEnumerable Filter(IEnumerable x, FilterFunction y)
		{
			return new FilterEnumerable(x, y);
		}

		class FilterEnumerable : IEnumerable
		{
			private readonly IEnumerable x;
			private readonly FilterFunction y;

			public FilterEnumerable(IEnumerable source, FilterFunction lambda)
			{
				x = source;
				y = lambda;
			}
			
			public IEnumerator GetEnumerator()
			{
				return new Enumerator(x.GetEnumerator(), y);
			}

			class Enumerator : IMFEnumerator
			{
				private readonly IEnumerator x;
				private readonly FilterFunction y;
				private int pos = 0;

				public Enumerator(IEnumerator source, FilterFunction lambda)
				{
					x = source;
					y = lambda;
				}
				
				public object Current { get { return x.Current; } }

				public bool MoveNext()
				{
					while (true)
					{
						if (!x.MoveNext())
							return false;
						
						object result = y(x.Current);
						if (result is bool && ((bool) result))
						{
							++pos;
							return true;
						}
					}
				}

				public void Reset() {}
				public void Dispose() { MFEnumerator.Dispose(x); }
				public int Position { get { return pos; } }
			}
		}

		public static IEnumerable GroupItems(Altova.Mapforce.Group g)
		{
			return g.Items;
		}

		public static IEnumerable GroupBy(IEnumerable x, MFInvoke y)
		{
			var groups_cache = new Dictionary<object, SequenceCache>();
			var result = new SequenceCache(null);
			var item_enumerator = x.GetEnumerator();
			while (item_enumerator.MoveNext())
			{
				var key_enumerator = DistinctValues(y.Invoke(item_enumerator.Current)).GetEnumerator();
				while (key_enumerator.MoveNext())
				{
					SequenceCache group = null;
					if (!groups_cache.TryGetValue(key_enumerator.Current, out group))
					{
						group = new SequenceCache(null);
						groups_cache[key_enumerator.Current] = group;
						result.Append(new Altova.Mapforce.Group(key_enumerator.Current, group));
					}
					group.Append(item_enumerator.Current);
				}
			}
			return result;
		}

		delegate object GroupLambda(object o);


		public static IEnumerable GroupAdjacent(IEnumerable x, MFInvoke y)
		{
			return new GroupAdjacentEnumerable(x, y);
		}
		
	
		class GroupAdjacentEnumerable : IEnumerable
		{
			private readonly IEnumerable x;
			private readonly MFInvoke y;

			public GroupAdjacentEnumerable(IEnumerable source, MFInvoke lambda)
			{
				x = source;
				y = lambda;
			}

			public IEnumerator GetEnumerator()
			{
				return new Enumerator(x.GetEnumerator(), y);
			}

			class Enumerator : IMFEnumerator
			{
				private readonly IEnumerator baseEnum;
				private readonly MFInvoke y;
				private object head;
				private object cur;
				private int pos = 0;

				public Enumerator(IEnumerator source, MFInvoke lambda)
				{
					baseEnum = source;
					y = lambda;
					
				}
				public object Current { get { return cur; } }
				
				public bool MoveNext() 
				{
					if (head == null)
					{
						if (!baseEnum.MoveNext())
							return false;
						head = baseEnum.Current;
					}
					
					SequenceCache result = new SequenceCache(null);
					result.Append(head);
					object groupKeys = y.Invoke(head);
					object groupKey = First((IEnumerable) groupKeys);
					string keyString = groupKey.ToString();
					
					while (true)
					{
						if (!baseEnum.MoveNext())
						{
							head = null;
							break;
						}
						
						head = baseEnum.Current;
						object itemKeys = y.Invoke(head);
						object itemKey = First((IEnumerable)itemKeys);
						if (keyString == itemKey.ToString())
							result.Append(head);
						else
							break;	
					}
					
					cur = new Altova.Mapforce.Group(groupKey, result);
					pos++;
					return true;
				}

				public void Reset() {}
				public void Dispose() { MFEnumerator.Dispose(baseEnum); }
				public int Position { get { return pos; } }
			}
		}

		public static IEnumerable GroupStartingWith(IEnumerable x, MFInvoke y)
		{
			return new GroupStartingWithEnumerable(x, y);
		}

		class GroupStartingWithEnumerable : IEnumerable
		{
			private readonly IEnumerable source;
			private readonly MFInvoke lambda;

			public GroupStartingWithEnumerable(IEnumerable x, MFInvoke y)
			{
				source = x;
				lambda = y;
			}
			
			public IEnumerator GetEnumerator() 
			{
				return new Enumerator(source.GetEnumerator(), lambda);
			}

			class Enumerator : IMFEnumerator
			{
				private readonly IEnumerator baseEnum;
				private readonly MFInvoke lambda;
				private object head;
				private object cur;
				private int pos = 0;

				public Enumerator(IEnumerator x, MFInvoke y)
				{
					baseEnum = x;
					lambda = y;
				}
				
				public object Current { get { return cur; } } 
				
				public bool MoveNext()
				{
					if (head == null)
					{
						if (!baseEnum.MoveNext())
							return false;
						head = baseEnum.Current;
					}
					
					SequenceCache result = new SequenceCache(null);
					result.Append(head);
					
					while(true)
					{
						if (!baseEnum.MoveNext())
						{
							head = null;
							break;
						}
					
						head = baseEnum.Current;
						object itemKeys = lambda.Invoke(head);
						object itemKey = First((IEnumerable) itemKeys);
						bool b = (bool) itemKey;
						if (b)
							break;
						else
							result.Append(head);
					}
					
					cur = new Altova.Mapforce.Group(MFEmptySequence.Instance, result);
					pos++;
					return true;
				}

				public void Reset() {}
				public void Dispose() { MFEnumerator.Dispose(baseEnum); }
				public int Position { get { return pos; } }	
			}
		}

		public static IEnumerable GroupEndingWith(IEnumerable x, MFInvoke y)
		{
			return new GroupEndingWithEnumerable(x, y);
		}

		class GroupEndingWithEnumerable : IEnumerable
		{
			private readonly IEnumerable source;
			private readonly MFInvoke lambda;

			public GroupEndingWithEnumerable(IEnumerable x, MFInvoke y)
			{
				source = x;
				lambda = y;
			}
			
			public IEnumerator GetEnumerator() 
			{
				return new Enumerator(source.GetEnumerator(), lambda);
			}

			class Enumerator : IMFEnumerator
			{
				private readonly IEnumerator baseEnum;
				private readonly MFInvoke lambda;
				private object cur;
				private int pos = 0;

				public Enumerator(IEnumerator x, MFInvoke y)
				{
					baseEnum = x;
					lambda = y;
				}
				
				public object Current { get { return cur; } }
				public bool MoveNext()
				{
					if (!baseEnum.MoveNext())
						return false;
					
					SequenceCache result = new SequenceCache(null);
										
					while(true)
					{					
						object p = baseEnum.Current;
						result.Append(p);
						object itemKeys = lambda.Invoke(p);
						object itemKey = First((IEnumerable) itemKeys);
						bool b = (bool) itemKey;
						if (b)
							break;
						if (!baseEnum.MoveNext())
							break;
					}
					
					cur = new Altova.Mapforce.Group(MFEmptySequence.Instance, result);
					pos++;
					return true;
				}

				public void Reset() {}
				public void Dispose() { MFEnumerator.Dispose(baseEnum); }
				
				public int Position { get {	return pos;	} }	
			}
		}

		public static IEnumerable GroupIntoBlocks( IEnumerable sequence, decimal blocksize )
		{
			if ( blocksize<1.0m )
				throw new System.ArgumentException("The group size " + blocksize + " is invalid since it must be greater than or equal one.");

			return new GroupIntoBlocksEnumerable( sequence, blocksize );
		}

		class GroupIntoBlocksEnumerable : IEnumerable
		{
			private readonly IEnumerable sequence;
			private readonly decimal blocksize;

			public GroupIntoBlocksEnumerable( IEnumerable sequence, decimal blocksize )
			{
				this.sequence = sequence;
				this.blocksize = blocksize;
			}

			public IEnumerator GetEnumerator()
			{
				return new Enumerator( sequence.GetEnumerator(), blocksize );
			}

			class Enumerator : IMFEnumerator
			{
				private readonly IEnumerator enumerator;
				private readonly decimal blocksize;
				private object cur;
				private int pos = 0;

				public Enumerator( IEnumerator enumerator, decimal blocksize )
				{
					this.enumerator = enumerator;
					this.blocksize = blocksize;
				}

				public object Current { get { return cur; } }

				public bool MoveNext()
				{
					SequenceCache result = new SequenceCache( null );

					for ( decimal i = 0m; i < blocksize; i++ )
					{
						if ( !enumerator.MoveNext() )
							if ( i == 0m )
								return false;
							else
								break;

						result.Append( enumerator.Current );
					}

					cur = new Altova.Mapforce.Group( MFEmptySequence.Instance, result );
					pos++;
					return true;
				}

				public void Reset() {}
				public void Dispose() { MFEnumerator.Dispose( enumerator ); }
				
				public int Position { get {	return pos;	} }	
			}
		}

		public static IEnumerable ResolveFilename(String pattern)
		{
			if (pattern.IndexOf(':') > 1) // URLs can't be resolved
				return Box(pattern);
			return new ResolveFilenameEnumerable(pattern);
		}

		class ResolveFilenameEnumerable : IEnumerable
		{
			private readonly String search_pattern;

			public ResolveFilenameEnumerable(String pattern)
			{
				search_pattern = pattern;
			}

			public IEnumerator GetEnumerator() { return new Enumerator(search_pattern); }

			class Enumerator : IMFEnumerator
			{
				private readonly ArrayList files;
				private readonly IEnumerator current;
				private int position = -1;

				public Enumerator( String pattern )
				{
					files = new ArrayList();
					int nsep = pattern.Replace('\\', '/').LastIndexOf('/')+1;
					String rootpath = pattern.Substring(0, nsep);
					if ( rootpath == String.Empty )
						rootpath = ".";

					String searchpattern = pattern.Substring(nsep);
					System.IO.DirectoryInfo filefind = new System.IO.DirectoryInfo(rootpath);
					try
					{
						System.IO.FileSystemInfo[] fileinfos = filefind.GetFileSystemInfos(searchpattern);
						foreach (System.IO.FileSystemInfo fileinfo in fileinfos)
						{
							if (fileinfo is System.IO.DirectoryInfo)
								continue;

							if (fileinfo is System.IO.FileInfo)
							{
								files.Add(fileinfo.FullName);
							}
						}
					}
					catch(System.Exception)
					{
					}

					current = files.GetEnumerator();
					position = 0;
				}

				public bool MoveNext()
				{
					if (current.MoveNext() )
					{
						position++;
						return true;
					}
					return false;
				}

				public void Reset() { current.Reset(); }

				public object Current { get { return current.Current; } }

				public int Position { get { return position; } }
				public void Dispose() { MFEnumerator.Dispose(current); }
			}
		}

		public static IMFNode ResultDocument(string filename, string encoding, IMFNode content)
		{
			return (new MFDocument(filename, Box(content)));
		}
		
		public static IMFNode ResultDocument(string filename, string encoding, System.Collections.IEnumerable content)
		{
			return (new MFDocument(filename, content));
		}

		class NullEnumerable : System.Collections.IEnumerable, IMFEnumerator
		{
			public System.Collections.IEnumerator GetEnumerator() { return this; }
			public void Reset() {}
			public bool MoveNext() { return false; }
			public object Current { get { throw new InvalidOperationException("No current element."); } }
			public int Position { get { throw new InvalidOperationException("No current element."); } }

			public static readonly NullEnumerable Instance = new NullEnumerable();
			public void Dispose() {}
		}

		class SingletonEnumerable : System.Collections.IEnumerable 
		{ 
			private readonly object o; 
			public SingletonEnumerable(object o) { this.o = o; } 
			
			public IEnumerator GetEnumerator() { return new Enumerator(o); } 
			class Enumerator : IMFEnumerator 
			{ 
				private readonly object o; 
				private int state; 
				public Enumerator(object o) { this.o = o; } 
				public void Reset() { state = 0; } 
				public void Dispose() {}
				public object Current { get { return o; } } 
				public int Position { get { return 1; } } 
				public bool MoveNext() { if (++state > 2) state = 2; return state == 1; } 
			} 
		}

		public static System.Collections.IEnumerable Null()
		{
			return NullEnumerable.Instance;
		}

		public static System.Collections.IEnumerable Avg(System.Collections.IEnumerable source)
		{
			System.Collections.IEnumerator en = source.GetEnumerator();
			if (!en.MoveNext())
			{
				MFEnumerator.Dispose(en);
				return Null();
			}
			decimal acc = (decimal)en.Current;
			int cnt = 1;
			while (en.MoveNext())
			{
				acc += (decimal)en.Current;
				++cnt;
			}
			MFEnumerator.Dispose(en);
			return new SingletonEnumerable(acc / cnt);			
		}

		public static decimal Sum(System.Collections.IEnumerable source)
		{
			System.Collections.IEnumerator en = source.GetEnumerator();
			decimal acc = 0.0m;
			while (en.MoveNext())
				acc += (decimal)en.Current;
			
			MFEnumerator.Dispose(en);
			return acc;
		}

		public static int Count(System.Collections.IEnumerable source) 
		{
			System.Collections.IEnumerator en = source.GetEnumerator();
			int cnt = 0;
			while (en.MoveNext()) ++cnt;
			MFEnumerator.Dispose(en);
			return cnt;
		}


		public static System.Collections.IEnumerable Max(System.Collections.IEnumerable source)
		{
			System.Collections.IEnumerator en = source.GetEnumerator();
			if (!en.MoveNext())
			{
				MFEnumerator.Dispose(en);
				return Null();
			}
			decimal max = (decimal)en.Current;
			while (en.MoveNext())
			{
				decimal x = (decimal)en.Current;
				max = (max < x) ? x : max;
			}
			
			MFEnumerator.Dispose(en);
			return new SingletonEnumerable(max);			
		}

		public static System.Collections.IEnumerable Min(System.Collections.IEnumerable source)
		{
			System.Collections.IEnumerator en = source.GetEnumerator();
			if (!en.MoveNext())
			{
				MFEnumerator.Dispose(en);
				return Null();
			}
			decimal min = (decimal)en.Current;
			while (en.MoveNext())
			{
				decimal x = (decimal)en.Current;
				min = (min < x) ? min : x;
			}
			MFEnumerator.Dispose(en);
			return new SingletonEnumerable(min);			
		}

		public static System.Collections.IEnumerable MaxString(System.Collections.IEnumerable source)
		{
			System.Collections.IEnumerator en = source.GetEnumerator();
			if (!en.MoveNext())
			{
				MFEnumerator.Dispose(en);
				return Null();
			}
			string max = (string)en.Current;
			while (en.MoveNext())
			{
				string x = (string)en.Current;
				if (String.Compare(max, x, StringComparison.Ordinal) < 0)
					max = x;
			}
			
			MFEnumerator.Dispose(en);
			return new SingletonEnumerable(max);			
		}

		public static System.Collections.IEnumerable MinString(System.Collections.IEnumerable source)
		{
			System.Collections.IEnumerator en = source.GetEnumerator();
			if (!en.MoveNext())
			{
				MFEnumerator.Dispose(en);
				return Null();
			}
			string min = (string)en.Current;
			while (en.MoveNext())
			{
				string x = (string)en.Current;
				if (String.Compare(min, x, StringComparison.Ordinal) > 0)
					min = x;
			}
			MFEnumerator.Dispose(en);
			return new SingletonEnumerable(min);			
		}

		public static string StringJoin(System.Collections.IEnumerable source, System.Collections.IEnumerable delimiter)
		{
			string delim = "";
			if (Exists(delimiter)) delim = (string)First(delimiter);
			System.Collections.IEnumerator en = source.GetEnumerator();
			if (!en.MoveNext())
			{
				MFEnumerator.Dispose(en);
				return string.Empty;
			}
			System.Text.StringBuilder builder = new System.Text.StringBuilder((string)en.Current);
			while (en.MoveNext())
			{
				builder.Append(delim);
				builder.Append((string)en.Current);
			}
			MFEnumerator.Dispose(en);
			return builder.ToString();
		}


		public static System.Collections.IEnumerable Box(object o) { return new SingletonEnumerable(o); }
		
		public static bool Exists(System.Collections.IEnumerable x) 
		{ 
			IEnumerator en = x.GetEnumerator();
			bool b = en.MoveNext();
			MFEnumerator.Dispose(en);
			return b;
		}
		
		public static Altova.Types.QName NodeName(Altova.Mapforce.IMFNode n)
		{
			return new Altova.Types.QName(n.NamespaceURI, n.Prefix, n.LocalName);
		}
		
		public static object First(System.Collections.IEnumerable e) 
		{ 
			System.Collections.IEnumerator r = e.GetEnumerator(); 
			if (!r.MoveNext())
			{
				MFEnumerator.Dispose(r);
				throw new InvalidOperationException("The source node does not exist, which is invalid.\nIn order to process invalid input, disable optimizations based on min/maxOccurs in component settings.");
			}
			Object o = r.Current; 
			MFEnumerator.Dispose(r);
			return o;
		}

		public static object Last(System.Collections.IEnumerable e) 
		{ 
			System.Collections.IEnumerator r = e.GetEnumerator(); 
			if (!r.MoveNext()) 
			{
				MFEnumerator.Dispose(r);
				throw new InvalidOperationException("The source node does not exist, which is invalid.\nIn order to process invalid input, disable optimizations based on min/maxOccurs in component settings."); 
			}

			object o = r.Current;
			while (r.MoveNext())
				o = r.Current;
			MFEnumerator.Dispose(r);
			return o; 
		}

		// logical functions
		public static bool LogicalNot(bool b) { return !b; }
		public static bool LogicalOr(bool l, bool r) { return l | r; }
		public static bool LogicalAnd(bool l, bool r) { return l & r; }	

		// comparison functions
		public static bool Equal(bool a, bool b) { return a == b; }
		public static bool Equal(int a, int b) { return a == b; }
		public static bool Equal(uint a, uint b) { return a == b; }
		public static bool Equal(long a, long b) { return a == b; }
		public static bool Equal(ulong a, ulong b) { return a == b; }
		public static bool Equal(double a, double b) { return a == b; }
		public static bool Equal(string a, string b) { return string.CompareOrdinal(a, b) == 0; }
		public static bool Equal(Altova.Types.DateTime a, Altova.Types.DateTime b) { return a.CompareTo(b) == 0; }
		public static bool Equal(Altova.Types.Duration a, Altova.Types.Duration b) { return a.Value.Ticks == b.Value.Ticks; }
		public static bool Equal(decimal a, decimal b) { return a == b; }
		public static bool Equal(Altova.Types.QName a, Altova.Types.QName b) { return Equal(a.Uri, b.Uri) && Equal(a.LocalName, b.LocalName); }

		public static bool Greater(bool a, bool b) { return a & !b; }
		public static bool Greater(int a, int b) { return a > b; }
		public static bool Greater(uint a, uint b) { return a > b; }
		public static bool Greater(long a, long b) { return a > b; }
		public static bool Greater(ulong a, ulong b) { return a > b; }
		public static bool Greater(double a, double b) { return a > b; }
		public static bool Greater(string a, string b) { return string.CompareOrdinal(a, b) > 0; }
		public static bool Greater(Altova.Types.DateTime a, Altova.Types.DateTime b) { return a.CompareTo(b) > 0; }
		public static bool Greater(Altova.Types.Duration a, Altova.Types.Duration b) { return a.Value.Ticks > b.Value.Ticks; }
		public static bool Greater(decimal a, decimal b) { return a > b; }

		public static bool Less(bool a, bool b) { return !a & b; }
		public static bool Less(int a, int b) { return a < b; }
		public static bool Less(uint a, uint b) { return a < b; }
		public static bool Less(long a, long b) { return a < b; }
		public static bool Less(ulong a, ulong b) { return a < b; }
		public static bool Less(double a, double b) { return a < b; }
		public static bool Less(string a, string b) { return string.CompareOrdinal(a, b) < 0; }
		public static bool Less(Altova.Types.DateTime a, Altova.Types.DateTime b) { return a.CompareTo(b) < 0; }
		public static bool Less(Altova.Types.Duration a, Altova.Types.Duration b) { return a.Value.Ticks < b.Value.Ticks; }
		public static bool Less(decimal a, decimal b) { return a < b; }

		public static bool EqualOrGreater(bool a, bool b) { return !b | a; }
		public static bool EqualOrGreater(int a, int b) { return a >= b; }
		public static bool EqualOrGreater(uint a, uint b) { return a >= b; }
		public static bool EqualOrGreater(long a, long b) { return a >= b; }
		public static bool EqualOrGreater(ulong a, ulong b) { return a >= b; }
		public static bool EqualOrGreater(double a, double b) { return a >= b; }
		public static bool EqualOrGreater(string a, string b) { return string.CompareOrdinal(a, b) >= 0; }
		public static bool EqualOrGreater(Altova.Types.DateTime a, Altova.Types.DateTime b) { return a.CompareTo(b) >= 0; }
		public static bool EqualOrGreater(Altova.Types.Duration a, Altova.Types.Duration b) { return a.Value.Ticks >= b.Value.Ticks; }
		public static bool EqualOrGreater(decimal a, decimal b) { return a >= b; }

		public static bool EqualOrLess(bool a, bool b) { return !a | b; }
		public static bool EqualOrLess(int a, int b) { return a <= b; }
		public static bool EqualOrLess(uint a, uint b) { return a <= b; }
		public static bool EqualOrLess(long a, long b) { return a <= b; }
		public static bool EqualOrLess(ulong a, ulong b) { return a <= b; }
		public static bool EqualOrLess(double a, double b) { return a <= b; }
		public static bool EqualOrLess(string a, string b) { return string.CompareOrdinal(a, b) <= 0; }
		public static bool EqualOrLess(Altova.Types.DateTime a, Altova.Types.DateTime b) { return a.CompareTo(b) <= 0; }
		public static bool EqualOrLess(Altova.Types.Duration a, Altova.Types.Duration b) { return a.Value.Ticks <= b.Value.Ticks; }
		public static bool EqualOrLess(decimal a, decimal b) { return a <= b; }

		public static bool NotEqual(bool a, bool b) { return a != b; }
		public static bool NotEqual(int a, int b) { return a != b; }
		public static bool NotEqual(uint a, uint b) { return a != b; }
		public static bool NotEqual(long a, long b) { return a != b; }
		public static bool NotEqual(ulong a, ulong b) { return a != b; }
		public static bool NotEqual(double a, double b) { return a != b; }
		public static bool NotEqual(string a, string b) { return string.CompareOrdinal(a, b) != 0; }
		public static bool NotEqual(Altova.Types.DateTime a, Altova.Types.DateTime b) { return a.CompareTo(b) != 0; }
		public static bool NotEqual(Altova.Types.Duration a, Altova.Types.Duration b) { return a.Value.Ticks != b.Value.Ticks; }
		public static bool NotEqual(decimal a, decimal b) { return a != b; }
		public static bool NotEqual(Altova.Types.QName a, Altova.Types.QName b) { return NotEqual(a.Uri, b.Uri) || NotEqual(a.LocalName, b.LocalName); }

		// Mathematical functions
		public static int Modulus(int a, int b) { return a % b; }
		public static long Modulus(long a, long b) { return a % b; }
		public static uint Modulus(uint a, uint b) { return a % b; }
		public static ulong Modulus(ulong a, ulong b) { return a % b; }
		public static double Modulus(double a, double b) { return a % b; }
		public static decimal Modulus(decimal a, decimal b) { return a % b; }

		public static int Multiply(int a, int b) { return a * b; }
		public static long Multiply(long a, long b) { return a * b; }
		public static uint Multiply(uint a, uint b) { return a * b; }
		public static ulong Multiply(ulong a, ulong b) { return a * b; }
		public static double Multiply(double a, double b) { return a * b; }
		public static decimal Multiply(decimal a, decimal b) { return a * b; }

		public static int Subtract(int a, int b) { return a - b; }
		public static long Subtract(long a, long b) { return a - b; }
		public static uint Subtract(uint a, uint b) { return a - b; }
		public static ulong Subtract(ulong a, ulong b) { return a - b; }
		public static double Subtract(double a, double b) { return a - b; }
		public static decimal Subtract(decimal a, decimal b) { return a - b; }

		public static int Add(int a, int b) { return a + b; }
		public static long Add(long a, long b) { return a + b; }
		public static uint Add(uint a, uint b) { return a + b; }
		public static ulong Add(ulong a, ulong b) { return a + b; }
		public static double Add(double a, double b) { return a + b; }
		public static decimal Add(decimal a, decimal b) { return a + b; }

		public static int Divide(int a, int b) { return a / b; }
		public static long Divide(long a, long b) { return a / b; }
		public static uint Divide(uint a, uint b) { return a / b; }
		public static ulong Divide(ulong a, ulong b) { return a / b; }
		public static double Divide(double a, double b) { return a / b; }
		public static decimal Divide(decimal a, decimal b) { return a / b; }

		public static int Ceiling(int x) { return x; }
		public static uint Ceiling(uint x) { return x; }
		public static long Ceiling(long x) { return x; }
		public static ulong Ceiling(ulong x) { return x; }
		public static int Floor(int x) { return x; }
		public static uint Floor(uint x) { return x; }
		public static long Floor(long x) { return x; }
		public static ulong Floor(ulong x) { return x; }
		public static int Round(int x) { return x; }
		public static uint Round(uint x) { return x; }
		public static long Round(long x) { return x; }
		public static ulong Round(ulong x) { return x; }

		public static double Ceiling(double d) { return Math.Ceiling(d); }
		public static double Floor(double d) { return Math.Floor(d); }
		public static double Round(double d) { return Math.Floor(d + 0.5); }

		public static decimal Ceiling(decimal d) { decimal f = decimal.Floor(d); return f == d ? f : f + 1; }
		public static decimal Floor(decimal d) { return decimal.Floor(d); }
		public static decimal Round(decimal d) { return decimal.Floor(d + 0.5m); }
		
		// string functions
		public static string Concat(string a, string b) { return a + b; }
		
		public static string NormalizeSpace(string a)
		{
			string result = "";
			bool needSpace = false;
			for (int i=0; i < a.Length; i++)
			{
				char c = a[i];
				if (c ==' ' || c == '\t' || c == '\n' || c == '\r')
					needSpace = true;
				else
				{
					if (needSpace && result.Length != 0)
						result += ' ';
					result += c;
					needSpace = false;
				}
			}
			return result;
		}

		public static bool StartsWith(string str, string substr)
		{
			return str.StartsWith(substr);
		}

		public static int StringLength(string str)
		{
			return str.Length;
		}

		public static string Substring(string str, int start, int length)
		{
			int from = start;
			int to = start + length;
			if (from < 1) from = 1;
			if (to > str.Length + 1) to = str.Length + 1;
			if (to <= from) return string.Empty;
			int rfrom = from - 1;
			int rto = to - 1;
			return str.Substring(rfrom, rto - rfrom);
		}

		public static string Substring(string str, double start, double length)
		{
			double from = start;
			double to = start + length;
			if (from < 1) from = 1;
			if (to > str.Length + 1) to = str.Length + 1;
			if (to <= from) return string.Empty;
			int rfrom = (int)Math.Round(from) - 1;
			int rto = (int)Math.Round(to) - 1;
			if (rto > str.Length) rto = str.Length;
			if (rto <= rfrom) return string.Empty;
			return str.Substring(rfrom, rto - rfrom);
		}

		public static string Substring(string str, int start)
		{
			return Substring(str, start, null);
		}

		public static string Substring(string str, double start)
		{
			return Substring(str, start, null);
		}

		public static string Substring(string str, int start, object lengthNull)
		{
			return Substring(str, start, str.Length - start + 1);
		}

		public static string Substring(string str, double start, object lengthNull)
		{
			int istart = (int) start;
			return Substring(str, istart, lengthNull);
		}

		public static string SubstringAfter(string str, string substr)
		{
			int position = str.IndexOf( substr);
			if( position >= 0 )
				return (str.Substring(position + substr.Length));
			else
				return "";
		}

		public static string SubstringBefore(string str, string substr)
		{
			int position = str.IndexOf(substr);
			if( position >= 0 )
				return str.Substring(0, position);
			else
				return "";
		}

		public static string Translate(string a, string b, string c)
		{
			string result = "";
			for (int i=0; i< a.Length; i++)
			{
				char ai = a[i];
				int off = b.IndexOf(ai);
				if (off != -1 && off < c.Length)
					result += c[off];
				else if (off == -1)
					result += ai;
			}
			return result;
		}

		public static bool Contains(string str, string substr)
		{
			return str.IndexOf(substr) >= 0;
		}		

		// conversion functions
		public static bool ToBoolean(bool b) { return Altova.CoreTypes.CastToBool(b); }
		public static bool ToBoolean(int b) { return Altova.CoreTypes.CastToBool(b); }
		public static bool ToBoolean(uint b) { return Altova.CoreTypes.CastToBool(b); }
		public static bool ToBoolean(ulong b) { return Altova.CoreTypes.CastToBool(b); }
		public static bool ToBoolean(long b) { return Altova.CoreTypes.CastToBool(b); }
		public static bool ToBoolean(string b) { if (b == null || b.Length == 0) return false; return true;}
		public static bool ToBoolean(double b) { return Altova.CoreTypes.CastToBool(b); }
		public static bool ToBoolean(decimal b) { return Altova.CoreTypes.CastToBool(b); }
		public static bool ToBoolean(Altova.Mapforce.IMFNode n) { return ToBoolean(ToString(n)); }

		public static decimal ToNumber(bool b) { return Altova.CoreTypes.CastToDecimal(b); }
		public static decimal ToNumber(int b) { return Altova.CoreTypes.CastToDecimal(b); }
		public static decimal ToNumber(uint b) { return Altova.CoreTypes.CastToDecimal(b); }
		public static decimal ToNumber(long b) { return Altova.CoreTypes.CastToDecimal(b); }
		public static decimal ToNumber(ulong b) { return Altova.CoreTypes.CastToDecimal(b); }
		public static decimal ToNumber(double b) { return Altova.CoreTypes.CastToDecimal(b); }
		public static decimal ToNumber(string b) { return Altova.CoreTypes.CastToDecimal(b); }
		public static decimal ToNumber(decimal b) { return Altova.CoreTypes.CastToDecimal(b); }
		public static decimal ToNumber(Altova.Mapforce.IMFNode n) { return ToNumber(ToString(n)); }

		public static string ToString(object o)
		{
			if (o is bool)
				return Altova.CoreTypes.CastToString((bool)o);

			if (o is int)
				return Altova.CoreTypes.CastToString((int)o);

			if (o is uint)
				return Altova.CoreTypes.CastToString((uint)o);

			if (o is long)
				return Altova.CoreTypes.CastToString((long)o);

			if (o is ulong)
				return Altova.CoreTypes.CastToString((ulong)o);

			if (o is double)
				return Altova.CoreTypes.CastToString((double)o);

			if (o is string)
				return Altova.CoreTypes.CastToString((string)o);

			if (o is decimal)
				return Altova.CoreTypes.CastToString((decimal)o);

			if (o is Altova.Types.DateTime)
				return Altova.CoreTypes.CastToString((Altova.Types.DateTime)o);

			if (o is Altova.Types.Duration)
				return Altova.CoreTypes.CastToString((Altova.Types.Duration)o);

			if (o is Altova.Types.QName)
				return Altova.CoreTypes.CastToString((Altova.Types.QName)o);

			if (o is Altova.Mapforce.IMFNode)
				return Altova.Mapforce.MFNode.GetValue((Mapforce.IMFNode)o);

			return null;
		}
		
		public static IEnumerable DocumentURI(IEnumerable ns)
		{
			if (Exists(ns))
			{
			Altova.Mapforce.IMFDocumentNode doc = First(ns) as Altova.Mapforce.IMFDocumentNode;
			if (doc != null)
				return Box(doc.GetDocumentUri());
			}
			return MFEmptySequence.Instance;
		}
		
		public static IEnumerable TokenizeRegexp(string input, string pattern)
		{
		
			return TokenizeRegexp(input, pattern, "");
		}

		public static IEnumerable TokenizeRegexp(string input, string pattern, string flags)
		{
			RegexOptions flag = RegexOptions.ExplicitCapture;
			foreach(char c in flags)
			{
				switch(c)
				{
					case 's':
						flag |= RegexOptions.Singleline;
						break;

					case 'm':
						flag |= RegexOptions.Multiline;
						break;

					case 'i':
						flag |= RegexOptions.IgnoreCase;
						break;

					case 'x':
						flag |= RegexOptions.IgnorePatternWhitespace;
						break;

					default:
						throw new System.ArgumentException("regular expression flag \'" + c + "\' is illegal.");
				}
			}
			Regex rx = new Regex(pattern, flag);
			return new SequenceCache(rx.Split(input));
		}
		
		public static IEnumerable Tokenize(string input, string delimiter)
		{
			ArrayList tokens = new ArrayList();
			int i=0;
			int j=0;
			int dl = delimiter.Length;
			int il = input.Length;
			while(true)
			{
				i = input.IndexOf(delimiter, j);
				if (i == -1) 
				{
					tokens.Add(input.Substring(j));
					break;
				}
				tokens.Add(input.Substring(j, i-j));
				j = i + dl;
			}
			
			return new SequenceCache(tokens);
		}
		
		public static IEnumerable TokenizeByLength(string input, double length)
		{
			ArrayList tokens = new ArrayList();
			int l = input.Length;
			int step = (int) length;

			if (length < 1)
				throw new System.ArgumentException("Length for tokenizing is " + length + " which is invalid since it must be greater or equal than 1.");

			for (int i=0; i < l; i += step)
				if (i+step < l)
					tokens.Add(input.Substring(i, step));
				else
					tokens.Add(input.Substring(i));

			return new SequenceCache(tokens);
		}
		
		public static string CharFromCode(decimal val ) 
		{
			Char c = (char) val;
			if (val < 1 || val > 0xFFFF)
				throw new System.ArgumentException( "char-from-code(" + (int)val + ") undefined." );
			return c.ToString();
		}

		public static decimal CodeFromChar(string val ) 
		{
			if (val.Length == 0)
				return 0;
			return (decimal) val[0];
		}

		public static string FormatNumber(decimal number, string pattern)
		{
			DecimalFormatParser dfp = new DecimalFormatParser();
			DecimalFormatParser.DecimalFormat format = new DecimalFormatParser.DecimalFormat();
			if(!dfp.setPattern(pattern, format))
				throw new System.ArgumentException( "Incorrect pattern: '" + pattern + "'");
			return dfp.formatNumber( number);
		}

		public static string FormatDateTime( Altova.Types.DateTime dt, string pattern)
		{
			DateTimeFormatParser dtfp = new DateTimeFormatParser(pattern);
		
			return dtfp.formatDateTime(dt);
		}

		public static string FormatDateTime( Altova.Types.DateTime dt, string pattern, string language)
		{
			return FormatDateTime(dt, pattern);
		}

		public static Altova.Types.DateTime ParseDateTime( string sInput, string sPattern)
		{
			if( sPattern.Length == 0 )
				throw new System.ArgumentException( "Empty pattern.");

			DateTimeFormatParser dtfp = new DateTimeFormatParser( sPattern);

			return dtfp.parseDateTime(sInput);
		}

		public static decimal ParseNumber(string sNumber, string pattern)
		{
			DecimalFormatParser dfp = new DecimalFormatParser();
			DecimalFormatParser.DecimalFormat format = new DecimalFormatParser.DecimalFormat();
			if(!dfp.setPattern(pattern, format, true))
				throw new System.ArgumentException( "Incorrect pattern: '" + pattern + "'");
			return dfp.parseNumber( sNumber);
		}

		public static long AutoNumber(RuntimeContext context, string id, long start, long step, string restartOnChange)
		{
			long r = 0;
			
			if (!context.AutoNumberStateMap.ContainsKey(id) || ((RuntimeContext.AutoNumberStateEntry)context.AutoNumberStateMap[id]).restartOnChange != restartOnChange)
				r = start;
			else
				r = ((RuntimeContext.AutoNumberStateEntry)context.AutoNumberStateMap[id]).current + step;
			
			context.AutoNumberStateMap[id] = new RuntimeContext.AutoNumberStateEntry(r, restartOnChange);
			return r;
		}

		public static void ResetAutoNumber(RuntimeContext context, string id)
		{
			context.AutoNumberStateMap.Remove(id);
		}

		public static IEnumerable ThrowUserException(string content)
		{
			throw new Altova.UserException(content);
		}

		public static IMFNode CreateElement(Altova.Types.QName qname, IEnumerable content)
		{
			return new MFElement(qname.LocalName, qname.Uri, qname.Prefix, content);
		}

		public static IMFNode CreateElement(string nodename, IEnumerable content)
		{
			return new MFElement(nodename, content);
		}
		
		public static IMFNode CreateAttribute(Altova.Types.QName qname, IEnumerable content)
		{
			return new MFAttribute(qname.LocalName, qname.Uri, qname.Prefix, content);
		}

		public static IMFNode CreateAttribute(string nodename, IEnumerable content)
		{
			return new MFAttribute(nodename, content);
		}
		
		public static Altova.Types.QName CreateQName(string localname, string uri)
		{
			int sep = localname.IndexOf(':');
			if (sep >= 0)
				return new Altova.Types.QName(uri, localname.Substring(0, sep), localname.Substring(sep + 1));
			else
				return new Altova.Types.QName(uri, "", localname);
		}

		public static string LocalNameFromQName(Altova.Types.QName qn) {return qn.LocalName;}
		public static string NamespaceUriFromQName(Altova.Types.QName qn) {return qn.Uri;}
		
		public static IEnumerable SelectChildren(IMFNode node)
		{
			return node.Select(MFQueryKind.AllChildren, null);
		}

		public static IEnumerable SelectAttributes(IMFNode node)
		{
			return node.Select(MFQueryKind.AllAttributes, null);
		}

		public static IEnumerable FilterElements(Altova.Types.QName qname, IMFNode node)
		{
			return node.Select(MFQueryKind.ChildrenByQName, new XmlQualifiedName(qname.LocalName, qname.Uri));
		}

		public static IEnumerable FilterElements(string nodename, IMFNode node)
		{
			return node.Select(MFQueryKind.ChildrenByNodeName, nodename);
		}

		public static IEnumerable FilterAttributes(Altova.Types.QName qname, IMFNode node)
		{
			return node.Select(MFQueryKind.AttributeByQName, new XmlQualifiedName(qname.LocalName, qname.Uri));
		}

		public static IEnumerable FilterAttributes(string name, IMFNode node)
		{
			return node.Select(MFQueryKind.AttributeByNodeName, name);
		}

		public static bool NodeNameEqual(Altova.Types.QName qname, IMFNode node)
		{
			return qname.LocalName == node.LocalName && qname.Uri == node.NamespaceURI;
		}

		public static bool NodeNameEqual(string name, IMFNode node)
		{
			return name == node.NodeName;
		}

		public static bool AttributeNameEqual(Altova.Types.QName qname, IMFNode node)
		{
			return NodeNameEqual( qname, node );
		}

		public static IMFNode CreateNamespace(string prefix, string content)
		{
			if (prefix.Length == 0)
				return new MFAttribute("xmlns", "http://www.w3.org/2000/xmlns/", "", Box(content));
			else
				return new MFAttribute(prefix, "http://www.w3.org/2000/xmlns/", "xmlns", Box(content));
		}
		
		public static string GetPlatformPathDelimiter()
		{
			return System.IO.Path.DirectorySeparatorChar.ToString();
		}
		
		public static IMFNode CreateComment(string content)
		{
			string str = content.Replace("--", "- -");

			if (str.EndsWith("-"))
				str += " ";

			return new MFComment(str);
		}
		
		public static IMFNode CreateProcessingInstruction(string content, string name)
		{
			if (!content.Contains("?>"))
				return new MFProcessingInstruction(name, content);

			return new MFProcessingInstruction(name, content.Replace("?>", "? >"));
		}

		public static IMFNode CreateCData(string content)
		{
			return new MFCData(content);
		}

		public static IEnumerable GenerateSequence( decimal from, decimal to )
		{
			if ( from > to )
				return MFEmptySequence.Instance;

			return new GenerateSequenceEnumerable( from, to );
		}

		class GenerateSequenceEnumerable : IEnumerable
		{
			private readonly decimal from, to;

			public GenerateSequenceEnumerable( decimal from, decimal to )
			{
				this.from = from;
				this.to = to;
			}

			public IEnumerator GetEnumerator() { return new Enumerator( from, to ); }

			class Enumerator : IMFEnumerator
			{
				private decimal current;
				private readonly decimal to;
				private int pos = 0;

				public Enumerator( decimal from, decimal to )
				{
					this.current = from;
					this.to = to;
				}

				public bool MoveNext()
				{
					if ( pos >= 1 )
					{
						if ( current == to )
							return false;
						current++;
					}
					pos++;
					return true;
				}

				public void Reset() {}

				public object Current { get { return current; } }

				public int Position { get { return pos; } }
				public void Dispose() {}
			}
		}

		public static IEnumerable ReplicateSequence( IEnumerable sequence, decimal count )
		{
			if ( count < 0.0m )
				throw new System.ArgumentException("Replication count is " + count + " which is invalid since it must not be negative.");

			if ( count == 0.0m )
				return MFEmptySequence.Instance;

			if ( count == 1.0m )
				return sequence;

			return new ReplicateSequenceEnumerable( sequence, count );
		}

		class ReplicateSequenceEnumerable : IEnumerable
		{
			private readonly IEnumerable sequence;
			private readonly decimal count;

			public ReplicateSequenceEnumerable( IEnumerable sequence, decimal count )
			{
				this.sequence = sequence;
				this.count = count;
			}

			public IEnumerator GetEnumerator() { return new Enumerator( sequence, count ); }

			class Enumerator : IMFEnumerator
			{
				private IEnumerable sequence;
				private IEnumerator enumerator;
				private decimal count;
				private int pos = 0;

				public Enumerator( IEnumerable sequence, decimal count )
				{
					this.sequence = sequence;
					this.enumerator = sequence.GetEnumerator();
					this.count = count;
				}

				public bool MoveNext()
				{
					while ( true )
					{
						if ( enumerator.MoveNext() )
						{
							pos++;
							return true;
						}

						if ( --count == 0.0m )
						{
							sequence = null;
							enumerator = null;
							return false;
						}

						enumerator = sequence.GetEnumerator();
					}
				}

				public void Reset() {}

				public object Current { get { return enumerator.Current; } }

				public int Position { get { return pos; } }

				public void Dispose()
				{
					MFEnumerator.Dispose( enumerator );
					enumerator = null;
					sequence = null;
				}
			}
		}

		class FilterSequenceByPositionRange : IEnumerable
		{
			private readonly IEnumerable sequence;
			private readonly decimal from, till;		// 1-based, both inclusive

			public FilterSequenceByPositionRange( IEnumerable sequence, decimal from, decimal till )
			{
				this.sequence = sequence;
				this.from = from;
				this.till = till;
			}

			public IEnumerator GetEnumerator()
			{
				if ( till < from )
					return MFEmptySequence.Instance.GetEnumerator();

				decimal skip = from > 0m ? from - 1m : 0m;
				decimal take = till - skip;

				return new Enumerator( sequence.GetEnumerator(), skip, take );
			}

			class Enumerator : IMFEnumerator
			{
				private readonly IEnumerator enumerator;
				private decimal skip, take;
				private int pos = 0;

				public Enumerator( IEnumerator enumerator, decimal skip, decimal take )
				{
					this.enumerator = enumerator;
					this.skip = skip;
					this.take = take;
				}

				public bool MoveNext()
				{
					while ( skip > 0m )
					{
						--skip;
						if ( !enumerator.MoveNext() )
							return false;
					}

					if ( take == 0m )
						return false;

					--take;
					if ( !enumerator.MoveNext() )
						return false;

					pos++;
					return true;
				}

				public void Reset() {}

				public object Current { get { return enumerator.Current; } }

				public int Position { get { return pos; } }

				public void Dispose() { MFEnumerator.Dispose( enumerator ); }
			}
		}

		public static IEnumerable ItemAt( IEnumerable sequence, decimal position )
		{
			return new FilterSequenceByPositionRange( sequence, position, position );
		}

		public static IEnumerable ItemsFromTill( IEnumerable sequence, decimal from, decimal till )
		{
			return new FilterSequenceByPositionRange( sequence, from, till );
		}

		public static IEnumerable FirstItems( IEnumerable sequence, decimal count )
		{
			return new FilterSequenceByPositionRange( sequence, 1m, count );
		}

		public static IEnumerable SkipFirstItems( IEnumerable sequence, decimal count )
		{
			return new FilterSequenceByPositionRange( sequence, count + 1m, Decimal.MaxValue );
		}

		public static IEnumerable LastItems( IEnumerable sequence, decimal count )
		{
			decimal len = (decimal) Count( sequence );
			decimal start = count > len ? 1m : len - count + 1m;
			return new FilterSequenceByPositionRange( sequence, start, len );
		}
	}
}

