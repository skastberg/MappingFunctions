////////////////////////////////////////////////////////////////////////
//
// Parser.cs
//
// This file was generated by MapForce 2021r3.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the MapForce Documentation for further details.
// http://www.altova.com/mapforce
//
////////////////////////////////////////////////////////////////////////

using System;
using System.Collections;
using System.Text;
using System.IO;

namespace Altova.TextParser.EDI
{
	/// <summary>
	/// Validates the value of a data field. 
	/// </summary>
	public class DataValueValidator
	{
		/// <summary>
		/// Indicates if value cannot be validated fully.
		/// </summary>
		/// <returns>True, if code list is incomplete. Alert only.</returns>
		public virtual bool IsIncomplete() { return false; }

		/// <summary>
		/// Checks if the given value is valid.
		/// </summary>
		/// <param name="value">The value of field.</param>
		/// <returns>True, if a value is valid.</returns>
		public virtual bool HasValue(String value) { return true; }

		/// <summary>
		/// Returns a String containing all possible values or a text that describes them.
		/// </summary>
		/// <returns>String with values of the codelist or a text.</returns>
		public virtual String GetCodeListValues() { return ""; }
	}

	public class DataValueCodeListValidator : DataValueValidator
	{
		protected bool mComplete;
		protected String[] mCodeList = null;

		public DataValueCodeListValidator(bool complete, String[] codeList)
		{
			this.mComplete = complete;
			this.mCodeList = codeList;
		}

		/// <summary>
		/// Indicates if value cannot be validated fully.
		/// </summary>
		/// <returns>True, if code list is incomplete. Alert only.</returns>
		public override bool IsIncomplete() { return !mComplete; }

		/// <summary>
		/// Checks if the given value is in the codelist.
		/// </summary>
		/// <param name="value">The value of field.</param>
		/// <returns>True, if a value is valid.</returns>
		public override bool HasValue(String value)
		{
			if (mCodeList != null)
			{
				for (int i = 0; i < mCodeList.Length; i++)
				{
					if (value == mCodeList[i])
						return true;
				}
			}
			else
				return true;

			return false;
		}

		/// <summary>
		/// Returns a String containing all values of the codelist.
		/// </summary>
		/// <returns>String with values of the codelist.</returns>
		public override String GetCodeListValues()
		{
			StringBuilder sb = new StringBuilder();
			if (mCodeList != null)
			{
				for (int i = 0; i < mCodeList.Length; i++)
				{
					if (sb.Length > 0)
						sb.Append(", ");
					sb.Append(mCodeList[i]);
				}
			}
			return sb.ToString();
		}
	}

	public class DataValueSubCodeListValidator : DataValueCodeListValidator
	{
		protected int mPosOffset;
		protected int mPosLength;

		public DataValueSubCodeListValidator(bool complete, int posOffset, int posLength, String[] codeList) : base(complete, codeList)
		{
			this.mPosOffset = posOffset;
			this.mPosLength = posLength;
		}

		/// <summary>
		/// Checks if the given value is in the codelist.
		/// </summary>
		/// <param name="value">The value of field.</param>
		/// <returns>True, if a value is valid.</returns>
		public override bool HasValue(String value)
		{
			if (mCodeList != null)
			{
				if (mPosOffset > 0)
				{
					if (value.Length > mPosOffset - 1)
						value = value.Substring(mPosOffset - 1, mPosLength);
					else
						value = "";
				}
				for (int i = 0; i < mCodeList.Length; i++)
				{
					if (value == mCodeList[i])
						return true;
				}
			}
			else
				return true;

			return false;
		}
	}

	public class DataValueGroupValidator : DataValueValidator
	{
		protected String mName;
		protected DataValueValidator[] mValidators;

		public DataValueGroupValidator(String name, DataValueValidator[] validators)
		{
			this.mName = name;
			this.mValidators = validators;
		}

		/// <summary>
		/// Indicates if value cannot be validated fully.
		/// </summary>
		/// <returns>True, if code list is incomplete. Alert only.</returns>
		public override bool IsIncomplete()
		{
			foreach (DataValueValidator validator in mValidators)
			{
				if (validator.IsIncomplete())
					return true;
			}
			return false;
		}

		/// <summary>
		/// Checks if the given value is in the codelist.
		/// </summary>
		/// <param name="value">The value of field.</param>
		/// <returns>True, if a value is valid.</returns>
		public override bool HasValue(String value)
		{
			foreach (DataValueValidator validator in mValidators)
			{
				if (!validator.HasValue(value))
				{
					return false;
				}
			}

			return true;
		}

		/// <summary>
		/// Returns a String containing all values of the codelist.
		/// </summary>
		/// <returns>String with values of the codelist.</returns>
		public override String GetCodeListValues()
		{
			if (mName.Length > 0)
				return "Values from code list " + mName;

			StringBuilder sb = new StringBuilder();
			for (int i = 0; i < mValidators.Length; ++i)
			{
				string s = mValidators[i].GetCodeListValues();
				if (s.Length > 0)
				{
					if (sb.Length > 0)
						sb.Append("; ");
					sb.Append(s);
				}
			}
			return sb.ToString();
		}
	}

	public class DataValueGroupsValidator : DataValueValidator
	{
		protected DataValueValidator[] mValidators;

		public DataValueGroupsValidator(DataValueValidator[] validators)
		{
			this.mValidators = validators;
		}

		/// <summary>
		/// Indicates if value cannot be validated fully.
		/// </summary>
		/// <returns>True, if code list is incomplete. Alert only.</returns>
		public override bool IsIncomplete()
		{
			foreach (DataValueValidator validator in mValidators)
			{
				if (validator.IsIncomplete())
					return true;
			}
			return false;
		}

		/// <summary>
		/// Checks if the given value is in the codelist.
		/// </summary>
		/// <param name="value">The value of field.</param>
		/// <returns>True, if a value is valid.</returns>
		public override bool HasValue(String value)
		{
			foreach (DataValueValidator validator in mValidators)
			{
				if (validator.HasValue(value))
					return true;
			}

			return false;
		}

		/// <summary>
		/// Returns a String containing all values of the codelist.
		/// </summary>
		/// <returns>String with values of the codelist.</returns>
		public override String GetCodeListValues()
		{
			StringBuilder sb = new StringBuilder();
			for (int i = 0; i < mValidators.Length; ++i)
			{
				string s = mValidators[i].GetCodeListValues();
				if (s.Length > 0)
				{
					if (sb.Length > 0)
						sb.Append("; ");
					sb.Append(s);
				}
			}
			return sb.ToString();
		}
	}
	
	/// <summary>
	/// Validates the information stored in a data field on read and write. 
	/// </summary>
	public class DataTypeValidator
	{
		protected int mMinLength;
		protected int mMaxLength;
		protected DataValueValidator mValueValidator;

		public DataTypeValidator(int minLength, int maxLength, DataValueValidator valueValidator)
		{
			this.mMinLength = minLength;
			this.mMaxLength = maxLength;
			this.mValueValidator = valueValidator;
		}
		
		public int MaxLength
		{
			get { return mMaxLength; }
		}

		/// <summary>
		/// Indicates if value cannot be validated fully.
		/// </summary>
		/// <returns>True, if code list is incomplete. Alert only.</returns>
		public bool IsIncomplete()
		{
			if (mValueValidator != null)
				return mValueValidator.IsIncomplete();
			return false;
		}
		
		/// <summary>
		/// Checks if the given value is in the codelist.
		/// </summary>
		/// <param name="s">The data field.</param>
		/// <param name="context">The current read context.</param>
		/// <returns>True, if a valid data field could be created.</returns>
		public bool HasValue(String value)
		{
			if (mValueValidator != null)
				return mValueValidator.HasValue(value);
			return true;
		}

		/// <summary>
		/// Returns a String containing all values of the codelist.
		/// </summary>
		/// <returns>String with values of the codelist.</returns>
		public String GetCodeListValues()
		{
			if (mValueValidator != null)
				return mValueValidator.GetCodeListValues();
			return "";
		}

		/// <summary>
		/// Checks if the string has a valid length.
		/// </summary>
		/// <param name="effLen">Effective string length.</param>
		/// <param name="s">String to check.</param>
		/// <param name="node">Current TextNode.</param>
		/// <param name="writer">Writer object to report the error.</param>
		protected void ValidateLength( int effLen, string s, ITextNode node, Writer writer)
		{
			//report error/warning
			if( effLen > mMaxLength)
			{
				writer.HandleError( 
					node,
					ParserError.DataElementTooLong,
					ErrorMessages.GetDataElementTooLongMessage( node.Name, mMaxLength, s)
				);
			}
			else if( effLen < mMinLength)
			{
				writer.HandleError( 
					node,
					ParserError.DataElementTooShort, 
					ErrorMessages.GetDataElementTooShortMessage( node.Name, mMaxLength, s)
				);
			}
		}
		
		/// <summary>
		/// Checks if the string has a valid length.
		/// </summary>
		/// <param name="effLen">Effective string length.</param>
		/// <param name="s">String to check.</param>
		/// <param name="node">Current TextNode.</param>
		/// <param name="context">Context object to report the error.</param>
		protected void ValidateLength( int effLen, string s, Parser.Context context, Scanner.State beforeReadState)
		{
			//report error/warning
			if( effLen > mMaxLength)
			{
				context.HandleError( 
					ParserError.DataElementTooLong,
					new ErrorPosition( beforeReadState),
					ErrorMessages.GetDataElementTooLongMessage(context.Particle.Node.Name, mMaxLength, s),
					s
				);
			}
			else if( effLen < mMinLength)
			{
				context.HandleError( 
					ParserError.DataElementTooShort,
					new ErrorPosition( beforeReadState),
					ErrorMessages.GetDataElementTooShortMessage(context.Particle.Node.Name, mMinLength, s),
					s
				);
			}
		}
		
		/// <summary>
		/// Makes a data field valid after reading it. 
		/// </summary>
		/// <param name="s">The data field.</param>
		/// <param name="context">The current read context.</param>
		/// <param name="beforeReadState">State of the scanner before reading.</param>
		/// <returns>True, if a valid data field could be created.</returns>
		public virtual void MakeValidOnRead (ref string s, Parser.Context context, Scanner.State beforeReadState) { }

		/// <summary>
		/// Makes a data field valid before writing it.
		/// </summary>
		/// <param name="s">The data field.</param>
		/// <param name="writer">The writer.</param>
		/// <returns>True, if a valid data field could be created.</returns>
		/// <remarks>
		/// The rules on writing are more restrictive than on reading, as the output file
		/// is assumed to be conformant, while on input only a few adjustments are made.
		/// </remarks>
		public virtual bool MakeValidOnWrite (ref string s, ITextNode node, Writer writer) { return true; }
	}	

	/// <summary>
	/// Provides data type validation for string types. 
	/// </summary>
	public class DataTypeValidatorString : DataTypeValidator
	{
		/// <summary>
		/// Initializes a new instance of the string validator.
		/// </summary>
		/// <param name="minLength">The minimum length of the string field.</param>
		/// <param name="maxLength">The maximum length of the string field.</param>
		public DataTypeValidatorString(int minLength, int maxLength, DataValueValidator valueValidator) : base(minLength, maxLength, valueValidator)
		{
		}
	
		/// <summary>
		/// Makes a data field valid after reading it. 
		/// </summary>
		/// <param name="s">The data field.</param>
		/// <param name="context">The current read context.</param>
		/// <returns>True, if a valid data field could be created.</returns>
		public override void MakeValidOnRead (ref string s, Parser.Context context, Scanner.State beforeReadState) 
		{
			if (context.Parser.Settings.Standard == EDIStandard.EDIFixed)
				s = s.TrimEnd( );
			ValidateLength( s.Length, s, context, beforeReadState);
		}

		/// <summary>
		/// Makes a string valid. 
		/// </summary>
		/// <param name="s"></param>
		/// <param name="writer">The writer.</param>
		/// <returns></returns>
		/// <remarks>
		/// Strings are made valid by padding them to the right with spaces when they are too short
		/// and truncating them on the right when they are too long. 
		/// </remarks>
		public override bool MakeValidOnWrite (ref string s, ITextNode node, Writer writer) 
		{
			int toPad = writer.EDIKind == EDIStandard.EDIFixed ? mMaxLength : mMinLength;
			
			//cut too long strings
			if (writer.EDIKind == EDIStandard.EDIFixed && s.Length > mMaxLength)
				s = s.Remove(mMaxLength);
			
			if (writer.EDIKind == EDIStandard.EDITRADACOMS)
				s = s.ToUpper();

			if (s.Length < toPad)
				s = s.PadRight (toPad, ' ');

			ValidateLength( s.Length, s, node, writer);
			return true;			
		}

		
	}

	/// <summary>
	/// Provides data type validation for decimal.
	/// </summary>
	public class DataTypeValidatorDecimal : DataTypeValidator
	{
		int mImplicitDecimals;

		/// <summary>
		/// Constructs a new instance of the decimal type validator.
		/// </summary>
		/// <param name="minLength">The minimum length that shall be stored.</param>
		/// <param name="maxLength">The maximum length that shall be stored.</param>
		/// <param name="implicitDecimals">The number of implicit decimal digits.</param>
		public DataTypeValidatorDecimal (int minLength, int maxLength, int implicitDecimals) : base(minLength, maxLength, null)
		{
			this.mImplicitDecimals = implicitDecimals;
		}


		static bool checkNumber (string s)
		{
			// EDI allows only ASCII digits for numbers
			foreach (char c in s)
				if (c < '0' || c > '9')
					return false;
			return true;
		}

		/// <summary>
		/// Makes the value valid on read.
		/// </summary>
		/// <param name="s"></param>
		/// <param name="context"></param>
		/// <returns></returns>
		/// <remarks>
		/// This ensures that a decimal dot is inserted when implicit decimals is non-zero 
		/// and no decimal dot is present as of yet.
		/// </remarks>
		public override void MakeValidOnRead (ref string s, Parser.Context context, Scanner.State beforeReadState)
		{
			int effectiveLength = EffectiveLength(s, context.Scanner.ServiceChars.DecimalSeparator);
			ValidateLength(effectiveLength, s, context, beforeReadState);

			string str = s.Trim();

			if (str.Length == 0)
			{
				context.HandleError(
					ParserError.FieldValueInvalid,
					new ErrorPosition(beforeReadState),
					ErrorMessages.GetInvalidFieldValueMessage(context.Particle.Node.Name, s, "decimal"),
					s
				);
				return;
			}

			s = str;

			bool negative = false;

			// first character could be sign. 
			if (s[0] == '+' || s[0] == '-')
			{
				negative = s[0] == '-';
				s = s.Substring(1);
			}

			if (s.Length == 0)	// treat as null value; it is invalid beyond repair anyways
			{
				context.HandleError(
					ParserError.FieldValueInvalid,
					new ErrorPosition( beforeReadState),
					ErrorMessages.GetInvalidFieldValueMessage(context.Particle.Node.Name, s, "decimal"),
					s
				);
				return; 
			}

			char decimalMark = context.Scanner.ServiceChars.DecimalSeparator;
			int decimalPoint = s.LastIndexOf(decimalMark);
			if (decimalPoint < 0)	
				decimalPoint = s.LastIndexOfAny(new char[]{'.',','});		

			string integral;
			string fractional;

			if (decimalPoint >= 0)
			{
				integral = s.Substring(0, decimalPoint);
				fractional = s.Substring(decimalPoint + 1);
			}
			else if (mImplicitDecimals > 0)
			{
				// make string at least the number of decimals required in length
				s = s.PadLeft(mImplicitDecimals, '0');
				integral = s.Substring(0, s.Length - mImplicitDecimals);
				fractional = s.Substring(s.Length - mImplicitDecimals);
			}
			else
			{
				integral = s;
				fractional = "";
			}

			if (integral.Length == 0)
				integral = "0";
			else	
				integral = integral.Replace(decimalMark.ToString(), "").Replace(",", "").Replace(".", "");
			
			if (!checkNumber (integral) || !checkNumber (fractional))
			{
				context.HandleError(
					ParserError.FieldValueInvalid,
					new ErrorPosition( beforeReadState),
					ErrorMessages.GetInvalidFieldValueMessage(context.Particle.Node.Name, s, "decimal"),
					s
				);
				return;
			}

			if (fractional.Length > 0)
				fractional = "." + fractional;
			
			// reassemble properly
			if (negative)
				s = "-" + integral + fractional;
			else
				s = integral + fractional;
		}

		/// <summary>
		/// Validates on write. 
		/// </summary>
		/// <param name="s"></param>
		/// <param name="writer"></param>
		/// <returns></returns>
		public override bool MakeValidOnWrite (ref string s, ITextNode node, Writer writer)
		{
			if (s.Length == 0)
				return true; // do not pad nulls.

			bool negative = false;

			// first character could be sign. 
			if (s[0] == '+' || s[0] == '-')
			{
				negative = s[0] == '-';
				s = s.Substring(1);
			}

			if (s.Length == 0)
				return false; 

			if (mImplicitDecimals > 0)
			{
				s = s.Replace(',', '.');
				decimal d = Decimal.Parse(s, System.Globalization.CultureInfo.InvariantCulture.NumberFormat);
				d = Decimal.Round(d, mImplicitDecimals);
				s = d.ToString(System.Globalization.CultureInfo.InvariantCulture.NumberFormat);
			}
				
			// this is a safety measure:
			int decimalPoint = s.LastIndexOfAny (new char[]{'.', ','});
			string integral;
			string fractional;
			
			
			if (decimalPoint >= 0)
			{
				integral = s.Substring(0, decimalPoint);
				fractional = s.Substring(decimalPoint + 1);
			}
			else
			{
				integral = s;
				fractional = "";
			}

			// remove leading and trailing zeros.
			integral = integral.TrimStart ('0');
			if(writer.EDIKind != EDIStandard.EDIX12)
			{
				if (integral.Length == 0)
					integral = "0";
			}
			fractional = fractional.TrimEnd ('0');

			if (mImplicitDecimals > 0)
			{
				fractional = fractional.PadRight(mImplicitDecimals, '0');
				
				if (mMinLength > fractional.Length)
					integral = integral.PadLeft (mMinLength - fractional.Length, '0');
			}
			else
			{
				if (mMinLength > fractional.Length)
					integral = integral.PadLeft (mMinLength - fractional.Length, '0');

				if (fractional.Length > 0)
					fractional = "." + fractional;
				// do not adjust integral, leading . is allowed
			}
			
			if (negative)
				s = "-" + integral + fractional;
			else
				s = integral + fractional;
				
			if (fractional.Length > 0 && EffectiveLength(s, '.') > mMaxLength)
			{
				decimal d = decimal.Parse(s, System.Globalization.CultureInfo.InvariantCulture.NumberFormat);
				int places = mMaxLength - integral.Length;
				if (negative)
					places++;
				if (places > 0) // don't round if maxlength is smaller than integral part
				{
					d = Decimal.Round(d, places, MidpointRounding.AwayFromZero);
					s = d.ToString(System.Globalization.CultureInfo.InvariantCulture.NumberFormat);
				}
			}
				
			s = s.Replace('.', writer.ServiceChars.DecimalSeparator);
			ValidateLength(EffectiveLength(s, writer.ServiceChars.DecimalSeparator), s, node, writer);
			return true;
		}
		
		private int EffectiveLength(string s, char point)
		{
			int effLen = s.Length;
			if (s[0] == '-' || s[0] == '+')
				effLen--;
			if (point != 0 && s.IndexOf(point) > 0)
				effLen--;

			return effLen;
		}
	}

	/// <summary>
	/// Provides data type validation for time.
	/// </summary>
	public class DataTypeValidatorTime : DataTypeValidator
	{
		/// <summary>
		/// Initializes a new instance of DataTypeValidatorTime.
		/// </summary>
		/// <param name="minLength"></param>
		/// <param name="maxLength"></param>
		public DataTypeValidatorTime (int minLength, int maxLength) : base(minLength, maxLength, null)
		{
		}

		/// <summary>
		/// Makes the value valid on read.
		/// </summary>
		/// <param name="s"></param>
		/// <param name="context"></param>
		/// <returns></returns>
		/// <remarks>
		/// This pads the time on input to the minimum length with zeroes.
		/// </remarks>
		public override void MakeValidOnRead (ref string s, Parser.Context context, Scanner.State beforeReadState)
		{
			ValidateLength(s.Length, s, context, beforeReadState);
			s = s.TrimStart();
			if (s.Length < 4 || s.Length == 5)
			{
				context.HandleError(
					ParserError.InvalidTime,
					new ErrorPosition(beforeReadState),
					ErrorMessages.GetInvalidTimeMessage(context.Particle.Node.Name, s, "time"),
					s
				);
				return;
			}
			
			if( !EDIDateTimeHelpers.IsTimeCorrect(s) )
				context.HandleError(
					ParserError.InvalidTime,
					new ErrorPosition(beforeReadState),
					ErrorMessages.GetInvalidTimeMessage(context.Particle.Node.Name, s, "time"),
					s
				);

			// ensure seconds are present
			if (s.Length <= 6)
				s = s.PadRight(6, '0');
			else
				s = s.Substring(0,6) + "." + s.Substring(6);
			
			s = s.Substring(0,2) + ":" + s.Substring(2,2) + ":" + s.Substring(4);
		}

		/// <summary>
		/// Ensures the value is valid on write.
		/// </summary>
		/// <param name="s"></param>
		/// <param name="writer"></param>
		/// <returns></returns>
		public override bool MakeValidOnWrite(ref string s, ITextNode node, Writer writer)
		{
			// remove date part
			s = s.Substring(s.IndexOf('T') + 1);
			
			// remove separators 
			s = s.Replace(":", "").Replace(".", "");
			int i = s.IndexOf("Z");
			if (i == -1)
				i = s.IndexOf("-");
			if (i == -1)
				i = s.IndexOf("+");
			if (i != -1)
				s = s.Substring(0, i);
			
			if (s.Length > mMaxLength)
			{
				if ( mMaxLength > 6 )
				{
					int rem = mMaxLength - 6;
					string ms = "0." + s.Substring(6, s.Length-6);
					double dms = double.Parse(ms, System.Globalization.CultureInfo.InvariantCulture.NumberFormat);
					s = s.Substring(0, 6);
					if( dms > 0.0 )
					{
						ms = Math.Round(dms, rem).ToString().PadRight(2 + rem, '0');
						s += ms.Substring(2, rem);
					}
				}
				else
					s = s.Substring(0, mMaxLength);
			}

			// truncate trailling zeroes, but enforce minlength.
			while (s.Length > mMinLength && s.Length > 6 && s[s.Length-1] == '0')
				s = s.Remove(s.Length-1, 1);
			
			return true;
		}
	}

	/// <summary>
	/// Provides data type validation for date.
	/// </summary>
	public class DataTypeValidatorDate : DataTypeValidator
	{
		/// <summary>
		/// Initializes a new instance of DataTypeValidatorDate.
		/// </summary>
		/// <param name="minLength"></param>
		/// <param name="maxLength"></param>
		public DataTypeValidatorDate (int minLength, int maxLength) : base(minLength, maxLength, null)
		{
		}

		/// <summary>
		/// Makes the value valid on read.
		/// </summary>
		/// <param name="s"></param>
		/// <param name="context"></param>
		/// <returns></returns>
		/// <remarks>
		/// This pads the time on input to the minimum length with zeroes.
		/// </remarks>
		public override void MakeValidOnRead (ref string s, Parser.Context context, Scanner.State beforeReadState)
		{
			ValidateLength(s.Length, s, context, beforeReadState);
			s = s.TrimStart();
			
			// six or eight digits shall be present, otherwise the format is entirely invalid
			if (s.Length != 6 && s.Length != 8)
			{
				context.HandleError(
					ParserError.InvalidDate,
					new ErrorPosition(beforeReadState),
					ErrorMessages.GetInvalidDateMessage(context.Particle.Node.Name, s, "date"),
					s
				);
				return;
			}

			foreach (char c in s)
			{
				if (c < '0' || c > '9')
				{
					context.HandleError(
						ParserError.InvalidDate,
						new ErrorPosition(beforeReadState),
						ErrorMessages.GetInvalidDateMessage(context.Particle.Node.Name, s, "date"),
						s
					);
					return;
				}
			}
			
			if (!EDIDateTimeHelpers.IsDateCorrect(s))
				context.HandleError(
					ParserError.InvalidDate,
					new ErrorPosition( beforeReadState),
					ErrorMessages.GetInvalidDateMessage(context.Particle.Node.Name, s, "date"),
					s
				);

			if (s.Length == 6)
			{
				if (s.Substring(0,2).CompareTo("50") < 0)
					s = "20" + s;
				else
					s = "19" + s;
			}

			// insert dashes
			s = s.Substring(0,4) + "-" + s.Substring(4,2) + "-" + s.Substring(6);
		}

		/// <summary>
		/// Ensures the value is valid on write.
		/// </summary>
		/// <param name="s"></param>
		/// <param name="writer"></param>
		/// <returns></returns>
		public override bool MakeValidOnWrite(ref string s, ITextNode node, Writer writer)
		{
			s = s.Trim();

			// string may be correctly formatted already, or may be an XML Schema date
			if (s.Length >= 10) 
			{
				// schema date: YYYY-MM-DDZZZZZ
				s = s.Substring(0,4) + s.Substring(5,2) + s.Substring(8,2);
			}

			// six or eight digits shall be present, otherwise the format is entirely invalid
			if (s.Length != 6 && s.Length != 8)
				return false;

			// trivial checks:
			if (mMaxLength == 6 && s.Length == 8)
				s = s.Substring(2);
			
			s = s.PadRight(mMinLength);			
			return true;
		}
	}
}

